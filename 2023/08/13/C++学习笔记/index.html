<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++学习笔记 | KAKA的个人博客</title><meta name="author" content="kaka"><meta name="copyright" content="kaka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++是一种支持多种编程范式的高效率、高性能的通用编程语言。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记">
<meta property="og:url" content="http://example.com/2023/08/13/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="KAKA的个人博客">
<meta property="og:description" content="C++是一种支持多种编程范式的高效率、高性能的通用编程语言。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/cover/c.jpg">
<meta property="article:published_time" content="2023-08-13T15:35:54.000Z">
<meta property="article:modified_time" content="2024-05-09T16:04:40.723Z">
<meta property="article:author" content="kaka">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/cover/c.jpg"><link rel="shortcut icon" href="/img/KA.png"><link rel="canonical" href="http://example.com/2023/08/13/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-10 00:04:40'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/cover/c.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="KAKA的个人博客"><span class="site-name">KAKA的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-13T15:35:54.000Z" title="发表于 2023-08-13 23:35:54">2023-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-09T16:04:40.723Z" title="更新于 2024-05-10 00:04:40">2024-05-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="欢迎来到C"><a href="#欢迎来到C" class="headerlink" title="欢迎来到C++"></a>欢迎来到C++</h1><p>C++可以直接控制硬件</p>
<p>C++几乎可以运行在全平台</p>
<p>C++可以编译为在各种平台上的本地代码,而C#或者java是在虚拟机上运行的,这意味着你的代码被编译成一种中间语言,当你的程序在目标平台上运行时,虚拟机在程序运行时,再转换为机器码</p>
<p>如果你写的代码很垃圾,你的代码很可能没有虚拟机代码要快,但你真正需要性能的时候,你需要C++</p>
<p>善用谷歌</p>
<h1 id="在Windows上安装C"><a href="#在Windows上安装C" class="headerlink" title="在Windows上安装C++"></a>在Windows上安装C++</h1><p>你完全可以用文本编辑器编写C++代码,比如记事本,当你写完之后,你需要通过编译器来生成可执行的二进制文件来运行程序,所以,我们需要一个集成开发环境</p>
<p>在这个教程里我们使用Visual Studio</p>
<p>VS中的解决方案是一组关联的项目,可以是各种项目类型,每个项目本本质上就是一组文件,被编译成二进制文件</p>
<h1 id="C-是如何工作的"><a href="#C-是如何工作的" class="headerlink" title="C++是如何工作的"></a>C++是如何工作的</h1><p>C++工作的基本流程是:你有一些C++源文件,将这些源文件给到编译器,编译将其转换成二进制的东西,这个东西可能是某种库,或者是可执行的程序</p>
<h2 id="C-源文件"><a href="#C-源文件" class="headerlink" title="C++源文件"></a>C++源文件</h2><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-04%20162954.png" alt="屏幕截图 2023-11-04 162954">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-11-04 162954.png)</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>编译器会先处理预处理语句,预处理语句在编译之前就被处理了</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>main是程序的入口,计算机从main开始逐行执行我们的代码,</p>
<p>main的返回值是int,main函数不写返回值也是被默许的,不写默认返回0</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/duke56/article/details/100165869">C语言main函数返回值详解-CSDN博客</a></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先,编译器先处理预处理语句,在上面的例子中,编译器将iostream文件的内容全部包含进来,这样的”包含”可以理解为简单的复制粘贴</p>
<p>处理完所有的预处理语句之后,我们的程序被编译,转换为机器代码,其中有些重要的设置决定我们怎么转换代码</p>
<p>在VS中,界面上方有两个设置,解决方案配置和解决方案平台,默认是debug和x86,解决方案配置是构建项目时的一系列规则,解决方案平台是你编译代码的目标平台</p>
<p>项目属性界面可以更改一些重要设置,其中,Configuration type默认设置为application(.exe),意味着我们要编译可运行文件,你也可以更改为编译库文件</p>
<p>默认的debug比release更慢,因为debug配置把许多优化关掉了,以支持我们调试代码</p>
<p>继续说编译,每个cpp文件都被编译成了一个object file(目标文件),如果你用的是VS,生成的文件后缀是.obj</p>
<p>当我们得到了所有的obj文件,有需要将这些文件合并成一个执行文件,此时需要链接器</p>
<p>我们可以用Ctrl+F7单独编译一个文件,此时还没有链接,我们在文件管理器中打开项目,在Debug目录下会发现多出了main.obj,对于每个cpp源文件,编译器都会生成对应的obj文件</p>
<p>如果我们生成整个项目,在另一个Debug目录下会发现.exe文件,双击即可运行</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>但如果是多文件,比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">C++</span><br><span class="line"><span class="comment">//Log.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数声明中你也可以不写参数名字</p>
<p>编译程序,因为main.cpp中有Log的声明,编译器会相信在其他的某个地方,比如这个文件下方或者其他文件中,会有Log函数的定义,声明就像一种约定</p>
<p>通过链接让声明的函数运行到正确的代码,如果在构建项目的时候找不到函数定义,就会出现链接错误,但如果仅仅编译文件,就不会出现,或者说还没有发现错误</p>
<h1 id="C-编译器是如何工作的"><a href="#C-编译器是如何工作的" class="headerlink" title="C++编译器是如何工作的"></a>C++编译器是如何工作的</h1><p>C++编译器不关心”文件”,文件只是提供给编译器源代码的一种方式,文件后缀的意义在于让编译器知道如何处理文件,如果是.cpp文件,编译器就用处理源的方式处理,如果是.h文件,编译器就用处理头文件的方式处理</p>
<p>文件后缀在windows中的作用也大概如此</p>
<h2 id="预处理-1"><a href="#预处理-1" class="headerlink" title="预处理"></a>预处理</h2><p>我们在上一篇的基础上在项目中加入一个文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Math.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = a * b;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译此文件</p>
<p>对比三个文件的目标文件</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20155156.png" alt="屏幕截图 2023-11-05 155156">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-11-05 155156.png)</p>
<p>你会发现Log.obj和main.obj很大,但Math.obj很小,是因为前两者中包含了iostream</p>
<p>我说过,include的作用基本上是简单的复制粘贴,我们做一个测试</p>
<p>加入文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EndBrace.h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改Math.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Math.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = a * b;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EndBrace.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>你会发现程序依然可以编译通过</p>
<hr>
<p>我们现在将”预处理到文件”打开</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20160208.png" alt="屏幕截图 2023-11-05 160208">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-11-05 160208.png)</p>
<p>修改Math.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Math.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTEGER int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = a * b;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EndBrace.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>编译后,你会发现项目文件夹中多了一个Math.i文件,.i后缀的文件是预编译处理后的文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 1 <span class="string">&quot;E:\\VS2022program\\LearnWithCheron\\LearnWithCheron\\Math.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = a * b;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 1 <span class="string">&quot;E:\\VS2022program\\LearnWithCheron\\LearnWithCheron\\EndBrace.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 10 <span class="string">&quot;E:\\VS2022program\\LearnWithCheron\\LearnWithCheron\\Math.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 12 <span class="string">&quot;E:\\VS2022program\\LearnWithCheron\\LearnWithCheron\\Math.cpp&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>继续修改Math.cpp,编译</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTEGER int</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = a * b;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EndBrace.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>你会发现我们得到了一个将近7万行的Math.i,最底部是我们自己的函数</p>
<h2 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h2><p>现在我们把”预处理到文件”关掉,不然编译器就不会生成.obj文件了</p>
<p>现在我们重新编译Math.cpp,然后查看它的目标文件</p>
<p>如果你用记事本打开.obj文件,你会发现它是二进制,或者是一堆乱码,总之是不可读的,我们现在用VS将其转换成可读的内容</p>
<p>更改项目属性,编译</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20161726.png" alt="屏幕截图 2023-11-05 161726">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-11-05 161726.png)</p>
<p>现在我们得到了一个Math.asm文件,打开</p>
<p>现在这个东西基本上是可读的了,你会发现一堆汇编指令,呈现了我们代码具体执行时的细节</p>
<p>比如<code>int res = a * b</code>对应的是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">; Line <span class="number">6</span></span><br><span class="line">	mov	eax, DWORD PTR a$[rbp]</span><br><span class="line">	imul	eax, DWORD PTR b$[rbp]</span><br><span class="line">	mov	DWORD PTR res$[rbp], eax</span><br></pre></td></tr></table></figure>

<hr>
<p>总之现在我们有了编译后的.obj文件,可以开始链接了</p>
<h1 id="C-链接器是如何工作的"><a href="#C-链接器是如何工作的" class="headerlink" title="C++链接器是如何工作的"></a>C++链接器是如何工作的</h1><p>链接对于C++程序的运行是必要的,就算你将所有的代码写在一个文件里,应用程序依然需要知道入口在哪,也就是main函数在哪</p>
<p>在项目属性中,你可以找到一个设置可以更改程序的入口,这说明程序入口可以不是main函数,但通常而且默认是main函数</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20170453.png" alt="屏幕截图 2023-11-05 170453">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-11-05 170453.png)</p>
<hr>
<p>继续上一篇,现在将项目属性改为默认,修改Math.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = a * b;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ctrl+F7,编译通过,右键项目点击”生成”,我们得到了一个链接错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&gt;E:\VS2022program\LearnWithCheron\x64\Debug\LearnWithCharno.exe : fatal error LNK1169: 找到一个或多个多重定义的符号</span><br></pre></td></tr></table></figure>

<p>这是因为void Log(const char*)在Log.cpp中也定义过一次</p>
<hr>
<p>现在我们删除所有文件,只保留并修改Math.cpp,生成项目</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Log</span>(<span class="string">&quot;Multiply&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">Multiply</span>(<span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时会出现链接错误,原因是没有Log的定义</p>
<p>继续修改,生成项目</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Log(&quot;Multiply&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">Multiply</span>(<span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接错误消失了,很好理解,Log没有被调用,也就不需要链接了</p>
<p>但如果我们这样修改,再次生成项目</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Log</span>(<span class="string">&quot;Multiply&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; Multiply(5, 8);</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到,虽然Multiply没有被调用,但Log被Multiply调用了,依然会出现链接错误</p>
<p>这是因为,虽然在这个脚本里我们没有使用Multiply,但在其他的脚本里我们有可以会使用Multiply,所以其需要链接</p>
<p>也就是说,如果我们可以告诉编译器,这个函数只会在这个脚本中使用,那么这个函数也就没有了链接的必要性</p>
<p>继续修改,生成项目</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Log</span>(<span class="string">&quot;Multiply&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; Multiply(5, 8);</span></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时没有链接错误</p>
<h1 id="C-变量"><a href="#C-变量" class="headerlink" title="C++变量"></a>C++变量</h1><p>C++中不同变量的唯一区别，在于它所需要的内存空间</p>
<p>数据类型的实际大小取决于编译器</p>
<p>以int举例，int通常需要4字节的空间，也就是32比特可以存储数据</p>
<p>变量的名称表示我们希望编译器应该分配给这个变量多少空间，如何理解和处理内存中存储的0和1，如果变量是int，编译器就会这样理解，有符号整形的其中一位存储正负号，剩下的31位存储二进制数字</p>
<h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p>我们不想写重复的代码，所以出现了函数</p>
<p>你可以将数学中函数的概念推移到编程中，函数可以输入参数，同时根据参数返回某些值</p>
<p>然而在编程中，很多东西都不是必须的，函数不一定要有参数，也不一定要返回值</p>
<p>此时你可以理解这个函数就是一组可复用的代码</p>
<p>main函数可以没有返回值，此时main函数会默认返回0</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/duke56/article/details/100165869">C语言main函数返回值详解-CSDN博客</a></p>
<h1 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C++头文件"></a>C++头文件</h1><p>我们需要一个公共的地方放置声明,不然就要复制粘贴所有函数的声明,这个公共的地方就是头文件</p>
<p>在头文件中,VS为我们插入了#pragma once,它的作用是使这个头文件只会被包含一次</p>
<p>如果没有#pragma once,我们有可能会在头文件包含链中多次包含同一个头文件,造成结构体或其他东西的重定义</p>
<p>注意不要让包含链首位链接</p>
<p>#include 后面的符号,尖括号只用于编译器包含路径,引号可以用于一切,但通常用在相对路径</p>
<p>你可以用文件名后面是否有.h区分C标准库和C++标准库</p>
<h1 id="如何在Visual-Studio中调试"><a href="#如何在Visual-Studio中调试" class="headerlink" title="如何在Visual Studio中调试"></a>如何在Visual Studio中调试</h1><p>当出现了错误,99%的情况都是你的问题,而不是计算机</p>
<p>你可以在程序中打断点,程序在调试模式下会在这个地方暂停,你可以在此处逐行执行并暂停程序</p>
<p>我们还可以在调试模式下观察内存,你可以在自动窗口中观察变量的变化,也可以在debug&#x2F;windows&#x2F;memory中查看具体的内存情况</p>
<h1 id="C-条件与分支"><a href="#C-条件与分支" class="headerlink" title="C++条件与分支"></a>C++条件与分支</h1><p>关于语法的部分我就不再赘述,这里说一些细节的部分</p>
<p>bool的本质是1字节的二进制数字,如果数字是0,则是false,如果不是,就是true</p>
<p>而if语句的本质是在检查这1字节是否为0</p>
<p>这个特性允许我们检查指针是否为空,因为指针为空时内存表示为0</p>
<h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C++循环"></a>C++循环</h1><h1 id="C-控制流语句"><a href="#C-控制流语句" class="headerlink" title="C++控制流语句"></a>C++控制流语句</h1><p>没什么好说的</p>
<h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++指针"></a>C++指针</h1><p>我们现在讨论point</p>
<p>我们要知道的是,所有的程序运行时,都需要加载进内存</p>
<p>想象图灵机,计算机内存就像一个长街,街上的每个房子都有一个地址</p>
<p>类型只是我们为了让生活更容易而创造的某种虚构,忘了类型吧,指针是一个整数,代表一个内存地址</p>
<p>我举个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">void</span>* ptr = &amp;var;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">double</span>* ptr = (<span class="type">double</span>*) &amp; var;</span><br></pre></td></tr></table></figure>

<p>都可以正确的取用var的地址</p>
<p>虽然但是,指针也是类型,指针变量也是变量,是变量就有地址,所以应该有指针的指针</p>
<p>而指针的指针也是类型…</p>
<p>我们可以用”*指针”来解引用,读写指针代表的地址</p>
<h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><p>根本上,引用是指针的伪装,是指针的语法糖</p>
<p>引用本身不是新的变量,没有内存空间,引用是已有变量的”引用”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout&lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span>&amp; ref = a;</span><br><span class="line"></span><br><span class="line">	ref = <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">LOG</span>(a);</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>从某种角度来说,ref就是a</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout&lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increment</span><span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span>&amp; ref = a;</span><br><span class="line"></span><br><span class="line">	ref = <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">Increment</span>(ref);</span><br><span class="line">	<span class="built_in">Increment</span>(a);</span><br><span class="line">	<span class="built_in">LOG</span>(a);</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>我们为函数传递的是变量的地址,然后在函数内在更改这个地址的数据</p>
<h1 id="C-类"><a href="#C-类" class="headerlink" title="C++类"></a>C++类</h1><p>总的来说,因为编程语言需要面向对象思想的好处,所以编程语言需要类</p>
<p>需要强调的是,面向对象只是一个思想,类只能简化你的代码,如果有一件不用类搞不定的事情,用类也一定搞不定</p>
<h1 id="C-类与结构体的对比"><a href="#C-类与结构体的对比" class="headerlink" title="C++类与结构体的对比"></a>C++类与结构体的对比</h1><p>C++中,类与结构体只有很小的区别,就是类和类成员可以修饰可见性</p>
<p>结构体在C++中依然存在的原因是C++需要兼容C</p>
<p>所以,如果没什么区别,那我该在什么时候用结构,什么时候用类呢?是不是我想要类的所有成员都是公共的,但又不想写public的时候就该用结构体呢?</p>
<p>还真是,就是这么点事</p>
<p>不过你也可以形成自己的习惯,如果你只需要一个数据集合,用结构体,如果这个数据集合需要隐藏数据,公开并封装操作,显然这个东西已经符合了对象的概念,用类</p>
<h1 id="如何写一个C-类"><a href="#如何写一个C-类" class="headerlink" title="如何写一个C++类"></a>如何写一个C++类</h1><p>我们现在写一个Log类,这是一个日志系统,在开发中起到重要的辅助作用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">C++</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> LogLevelInfo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_LogLevel = LogLevelInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_LogLevel = level;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(m_LogLevel &gt;= LogLevelError)</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;[Error]&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_LogLevel &gt;= LogLevelWarning)</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;[WARNING]&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_LogLevel &gt;= LogLevelInfo)</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;[Info]&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这不是啥好代码,但很有逻辑,如果你想知道C++里怎么写类,请</p>
<h1 id="C-中的静态"><a href="#C-中的静态" class="headerlink" title="C++中的静态"></a>C++中的静态</h1><h2 id="在类和结构体外使用的static"><a href="#在类和结构体外使用的static" class="headerlink" title="在类和结构体外使用的static"></a>在类和结构体外使用的static</h2><p>此时,static意味着链接只在内部,static修饰的东西只在你定义它的翻译单元内可见</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Static.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_Variable = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s_Variable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; s_Variable &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>如果我们将Static.cpp修改为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Static.cpp</span></span><br><span class="line"><span class="type">int</span> s_Variable = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>将得到链接错误</p>
<p>我们可以在main.cpp内使用extern关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> s_Variable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; s_Variable &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这表示,s_Variable将会在外部翻译单元中链接</p>
<p>如果我们将Static.cpp修改回去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Static.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_Variable = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>又会出现链接错误</p>
<h2 id="在类和结构体内使用的static"><a href="#在类和结构体内使用的static" class="headerlink" title="在类和结构体内使用的static"></a>在类和结构体内使用的static</h2><p>此时static代表其修饰的东西在该内存中只有一个实例,所有的对象共享这个成员</p>
<h2 id="C-中的局部静态"><a href="#C-中的局部静态" class="headerlink" title="C++中的局部静态"></a>C++中的局部静态</h2><p>你可以在局部作用域中使用static,这关系到变量的生命周期</p>
<p>static修饰的变量会在作用域结束后依然存在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	i++;</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="C-枚举"><a href="#C-枚举" class="headerlink" title="C++枚举"></a>C++枚举</h1><p>从某种角度来说,枚举就是你给数字加了名字</p>
<p>比如你需要一个东西有三种状态,用0,1,2去表示,完全可以,但它通常是一个int类型,你还可以赋值3,4…此时这个变量就没有意义了</p>
<p>我们需要让这种状态单独成为一个类型,在语法上强制用户只能使用”0,1,2”,此时我们就可以用枚举</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">	A,B,C</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Example value = B;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (value == B)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以给枚举赋值整数类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">	A = <span class="number">0</span>,B = <span class="number">1</span>,C = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Example value = B;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (value == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (value &gt; B)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举的值默认从零递增</p>
<h1 id="C-构造函数"><a href="#C-构造函数" class="headerlink" title="C++构造函数"></a>C++构造函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> X, Y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; X &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; Y &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity a;</span><br><span class="line">	a.<span class="built_in">Print</span>();</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">-1.07374e+08</span>,<span class="number">-1.07374e+08</span></span><br></pre></td></tr></table></figure>

<p>这是因为x和y没有被幅值,我们可以用一个初始化函数做到这件事</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但我们有更好的办法,构造函数</p>
<p>构造函数在对象被创建的时候运行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> X, Y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; X &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; Y &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		X = <span class="number">0</span>;</span><br><span class="line">		Y = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">float</span> x,<span class="type">float</span> y)</span><br><span class="line">	&#123;</span><br><span class="line">		X = x;</span><br><span class="line">		Y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity a = <span class="built_in">Entity</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	Entity b;</span><br><span class="line">	a.<span class="built_in">Print</span>();</span><br><span class="line">	b.<span class="built_in">Print</span>();</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>构造函数在对象创建的时候运行,如果你只使用这个类的静态方法,那么你就不需要使用构造函数</p>
<p>C++会提供默认构造函数,你可以用<code>类名() = delete;</code>将构造函数去掉</p>
<h1 id="C-析构函数"><a href="#C-析构函数" class="headerlink" title="C++析构函数"></a>C++析构函数</h1><p>析构函数在对象销毁时运行,堆对象在你使用delete的时候运行析构函数,栈对象在其生命周期结束时运行析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> X, Y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; X &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; Y &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		X = <span class="number">0</span>;</span><br><span class="line">		Y = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">float</span> x,<span class="type">float</span> y)</span><br><span class="line">	&#123;</span><br><span class="line">		X = x;</span><br><span class="line">		Y = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	Entity* a = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Destroyed Entity</span><br><span class="line">Destroyed Entity</span><br></pre></td></tr></table></figure>

<h1 id="C-继承"><a href="#C-继承" class="headerlink" title="C++继承"></a>C++继承</h1><p>我们可以将公共的功能放在父类中,这样就不用书写重复的代码了,这是继承最直观的作用</p>
<p>当然继承的作用远不止于此</p>
<p>同样,一个编程语言需要面向对象的好处,所以这个编程语言需要继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">float</span> X, Y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xa,<span class="type">float</span> ya)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		X += xa;</span><br><span class="line">		Y += ya;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时你可以认为Player有两个类型,一个是Player,一个是Entity</p>
<h1 id="C-虚函数"><a href="#C-虚函数" class="headerlink" title="C++虚函数"></a>C++虚函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Player</span>(<span class="type">const</span> std::string name)</span><br><span class="line">	:<span class="built_in">m_Name</span>(name)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">	std::cout &lt;&lt; e-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">	Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Pditine&quot;</span>);</span><br><span class="line">	std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	Entity* entity = p;</span><br><span class="line">	std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Entity</span><br><span class="line">Pditine</span><br><span class="line">Entity</span><br></pre></td></tr></table></figure>

<p>方法在类的内部起作用,当你要调用方法的时候,调用的是属于这个类型的方法</p>
<p>如果我们想要在第三次输出的时候令编译器认为应该调用Player里的方法,此时我们需要虚函数</p>
<p>虚函数通过V表实现编译,包含基类中所有虚函数的映射</p>
<p>我们用virtual关键字将父类中的方法标记为虚函数,也可以选择在子类方法中写override,这更规范,也可以避免一些语法错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Player</span>(<span class="type">const</span> std::string name)</span><br><span class="line">	:<span class="built_in">m_Name</span>(name)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">	std::cout &lt;&lt; e-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">	Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Pditine&quot;</span>);</span><br><span class="line">	std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	Entity* entity = p;</span><br><span class="line">	std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Entity</span><br><span class="line">Pditine</span><br><span class="line">Pditine</span><br></pre></td></tr></table></figure>

<h1 id="C-纯虚函数"><a href="#C-纯虚函数" class="headerlink" title="C++纯虚函数"></a>C++纯虚函数</h1><p>C++纯虚函数和其他语言的抽象方法和接口差不多</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Player</span>(<span class="type">const</span> std::string name)</span><br><span class="line">	:<span class="built_in">m_Name</span>(name)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Pditine&quot;</span>);</span><br><span class="line">	std::cout &lt;&lt; p-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	Entity* entity = p;</span><br><span class="line">	std::cout &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Pditine</span><br><span class="line">Pditine</span><br></pre></td></tr></table></figure>

<h1 id="C-可见性"><a href="#C-可见性" class="headerlink" title="C++可见性"></a>C++可见性</h1><p>关于用法就不说了</p>
<p>需要强调的是,可见性不是你的电脑需要理解的东西,是开发者需要理解的东西</p>
<p>将所有private改为public不会影响代码的功能,但绝对是个糟糕的想法</p>
<p>这不是功能的问题,但这关乎<strong>规范</strong>,这一个原因就足够你经常用private了</p>
<h1 id="C-数组"><a href="#C-数组" class="headerlink" title="C++数组"></a>C++数组</h1><p>C++数组基本上是变量的几何,通常是相同类型的变量</p>
<p>数组的名字是一个指针类型</p>
<p>你需要注意数字名后面的索引</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> example[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">	example[<span class="number">-1</span>] = <span class="number">12</span>;</span><br><span class="line">	example[<span class="number">5</span>] = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中,我们修改了不属于这个数组的内存,debug模式下ide会给你报错,但release模式下不会,你可能在不知不觉中犯了很大的错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">example[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">*(<span class="type">int</span>*)((<span class="type">char</span>*)example +<span class="number">8</span>) = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>上面这两行的作用是一样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="built_in">sizeof</span>(example) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>用上面的代码获取数组的长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::array&lt;<span class="type">int</span>, 5&gt; example;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以用array代替数组,会有额外的内存开销,但更安全</p>
<h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++字符串"></a>C++字符串</h1><p>字符串就是字符数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;Pditine&quot;</span>;</span><br><span class="line">	std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> name2[<span class="number">7</span>] = &#123;<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">	std::cout &lt;&lt; name2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Pditine</span><br><span class="line">Pditine烫烫烫烫烫烫烫烫烫烫烫烫烫烫泰,憲?</span><br></pre></td></tr></table></figure>

<p>这样写,后者会出现错误,这是因为字符数组內没有终止符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;Pditine&quot;</span>;</span><br><span class="line">	std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> name2[<span class="number">8</span>] = &#123;<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">	std::cout &lt;&lt; name2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Pditine</span><br><span class="line">Pditine</span><br></pre></td></tr></table></figure>

<p>不过,这些是C风格的字符串,在C++中,建议使用std::string,它基本上就是字符数组,一些其他数据和一些函数,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string name = <span class="string">&quot;Pditine&quot;</span>;</span><br><span class="line">	std::cout&lt;&lt;name &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你无法书写以下的代码,因为你不能用std::string类型相加const char*类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string name = &quot;Pditine&quot; + &quot;Hello&quot;;</span><br></pre></td></tr></table></figure>

<p>但你可以这么写,因为”+&#x3D;”在std::string中被重载了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string name = <span class="string">&quot;Pditine&quot;</span>;</span><br><span class="line">	name+=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">	std::cout&lt;&lt;name &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当std::string作为函数参数,尽量使用const std::string&amp;,因为传递string实际上很慢</p>
<h1 id="C-字符串字面量"><a href="#C-字符串字面量" class="headerlink" title="C++字符串字面量"></a>C++字符串字面量</h1><p>你可以在字符串中间加终止符,这会让字符串提前结束</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string name = <span class="string">&quot;Pdit\0ine&quot;</span>;</span><br><span class="line">	std::cout&lt;&lt;name &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Pdit</span><br></pre></td></tr></table></figure>

<p>有许多不同的字符类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* name = <span class="string">u8&quot;Pditine&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">wchar_t</span>* name2 = <span class="string">L&quot;Pditine&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char16_t</span>* name3 = <span class="string">u&quot;Pditine&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char32_t</span>* name4 = <span class="string">U&quot;Pditine&quot;</span>;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>

<h1 id="C-中的Const"><a href="#C-中的Const" class="headerlink" title="C++中的Const"></a>C++中的Const</h1><p>const在改变生成代码方面什么也做不了,有点像可见性,它是一种规范,是你做的承诺,让我们的代码更有可读性</p>
<p>被const修饰的变量是一个常量,初始化之后你无法修改它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<p>MAX_AGE在语法上是无法修改的</p>
<p>对于指针来说,以下两种写法代表无法改变指针代表地址的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* b = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure>

<p>以下写法代表无法改变指针变量的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure>

<p>总之,关键在于constr在*左边还是右边</p>
<hr>
<p>对于方法,const代表这个方法不会修改类成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_X, m_Y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_X;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们无法在方法里修改 m_X和m_Y的值</p>
<p>所以,如果需要,你可以写这样的shit</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> *m_X, *m_Y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_X;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个方法返回的指针不能被修改,指针代表地址的内容不能被修改,方法里不能修改类成员</p>
<hr>
<p>当函数或者方法参数是对象,你不会希望复制整个对象来传递数据的,更好的办法是用引用传递,这时,我们就可以决定是否要加一个承诺,承诺这个函数不会修改传入的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; e.<span class="built_in">GetX</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>现在我们做这样的事情</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_X, m_Y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; e.<span class="built_in">GetX</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity e = <span class="built_in">Entity</span>();</span><br><span class="line">	<span class="built_in">PrintEntity</span>(e);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>我们写两个版本的GetX,你发现PrintEntity调用的是有const的GetX</p>
<p>或者,如果我们有一个Entity常量,这个对象也只能调用const方法</p>
<hr>
<p>有时候,我们就是想破坏承诺,或许是为了调试,或者别的原因</p>
<p>你可以用mutable关键字实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_X, m_Y;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> var;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		var = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mutable使得这个成员变量在const方法内是可以改变的</p>
<h1 id="C-的mutable关键字"><a href="#C-的mutable关键字" class="headerlink" title="C++的mutable关键字"></a>C++的mutable关键字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_Name;</span><br><span class="line">	<span class="keyword">mutable</span>  <span class="type">int</span> m_DebugCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_DebugCount++;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除了这个,还有一个用mutable的地方,lambda表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">auto</span> f = [=]() <span class="keyword">mutable</span> </span><br><span class="line">	&#123;</span><br><span class="line">		x++;</span><br><span class="line">		std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">f</span>();</span><br><span class="line">	std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<h1 id="C-的成员初始化列表"><a href="#C-的成员初始化列表" class="headerlink" title="C++的成员初始化列表"></a>C++的成员初始化列表</h1><p>成员初始化列表是我们在构造函数为成员变量初始化的方式</p>
<p>确保初始化列表里变量的顺序和类里变量定义的顺序是一致的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>():<span class="built_in">m_Name</span>(<span class="string">&quot;Unknwn&quot;</span>),<span class="built_in">m_Score</span>(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name,<span class="type">int</span> score):<span class="built_in">m_Name</span>(name),<span class="built_in">m_Score</span>(score)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这就是初始化列表,问题在于,我们为什么使用初始化列表</p>
<p>一些是风格的问题,大部分是功能的问题</p>
<p>对于类内部的对象,你在不使用初始化列表,而使用方法参数构造时,你实际上创建了两个对象,然后丢弃了一个,比如以上代码中的m_Name,在不使用初始化列表的情况下,使用构造函数,会创建一个空的string,和一个幅值了的string,然后将这个空的string赋值为后者</p>
<h1 id="C-中的三元操作符"><a href="#C-中的三元操作符" class="headerlink" title="C++中的三元操作符"></a>C++中的三元操作符</h1><p>三元操作符实际上是if else的语法糖</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_Level = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_Speed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s_Level &gt; <span class="number">5</span>)</span><br><span class="line">		s_Speed = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		s_Speed = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	s_Speed = s_Level &gt; <span class="number">5</span> ? <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8~11行的代码和13行的代码的功能是一样的,后者就是三元运算符</p>
<p>我们可以在三元运算符里嵌套三元运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_Level = <span class="number">15</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_Speed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s_Speed = s_Level &gt; <span class="number">5</span> ? s_Level&gt;<span class="number">10</span>? <span class="number">15</span>: <span class="number">10</span> : <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; s_Speed &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<h1 id="创建并初始化C-对象"><a href="#创建并初始化C-对象" class="headerlink" title="创建并初始化C++对象"></a>创建并初始化C++对象</h1><p>你可以选择在栈或堆上创建对象,这表明你需要知道对象在栈和堆上的区别</p>
<p>在栈上创建时,你需要注意对象的生命周期是否是你想要的那样,同时如果对象过大,也不应创建在栈上</p>
<p>在堆上创建时,你需要使用new关键字,你需要内存管理,也就是适时手动销毁对象,但堆上有庞大的空间可以存储对象</p>
<h1 id="C-中的new关键字"><a href="#C-中的new关键字" class="headerlink" title="C++中的new关键字"></a>C++中的new关键字</h1><p>都2023年了,有那么多其他好用的语言,你只可能特别需要性能或者要掌控一切,才需要C++,在这个过程中,new是重要的关键字</p>
<p>当你使用new,你希望在堆中找到一块恰当的内存,并得到这个内存的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>当使用new了,就一定要记得delete</p>
<p>你也可以用new指定内存地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_Level = <span class="number">15</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_Speed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* b = <span class="built_in">new</span>(a) <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; *a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; *b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">2</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="C-隐式装换与explicit关键字"><a href="#C-隐式装换与explicit关键字" class="headerlink" title="C++隐式装换与explicit关键字"></a>C++隐式装换与explicit关键字</h1><p>一般来说,我们是这样写代码的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name):</span><br><span class="line">	<span class="built_in">m_Name</span>(name),<span class="built_in">m_Age</span>(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">int</span> age):<span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>),<span class="built_in">m_Age</span>(age	)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Entity <span class="title">a</span><span class="params">(<span class="string">&quot;Pditine&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Entity <span class="title">b</span><span class="params">(<span class="number">22</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但你也可以这样书写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity a =<span class="string">&quot;Pditine&quot;</span>;</span><br><span class="line"></span><br><span class="line">	Entity b = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你甚至可以这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PrintEntity</span>(<span class="number">22</span>);</span><br><span class="line">	<span class="built_in">PrintEntity</span>((std::string)<span class="string">&quot;Pditine&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Entity a =<span class="string">&quot;Pditine&quot;</span>;</span><br><span class="line"></span><br><span class="line">	Entity b = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会注意到以上代码第四行有强制类型转换,这是因为”Pditine”的类型是char[],而C++在这种情况下只允许一次隐式类型转换,而不能是char[]转换成string,再转换成Entity</p>
<p>这也能说明,我们在将”…”幅值给string的时候已经使用了隐式类型转换</p>
<hr>
<p>将explicit关键字放在构造函数前,意味着这个构造函数不能被用于隐式转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span>  <span class="title">Entity</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span>:</span></span><br><span class="line"><span class="function">	m_Name(name),m_Age(<span class="number">-1</span>)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">int</span> age)</span>:m_Name(<span class="string">&quot;Unknown&quot;</span>),m_Age(age	)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity a =(Entity)<span class="string">&quot;Pditine&quot;</span>;</span><br><span class="line"></span><br><span class="line">	Entity b = (Entity)<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-运算符及其重载"><a href="#C-运算符及其重载" class="headerlink" title="C++运算符及其重载"></a>C++运算符及其重载</h1><p>首先,你可能已经知道运算符是什么了,比如+,&#x3D;,或者&lt;,&gt;,.,&amp;</p>
<p>但你或许不知道,运算符就是函数,所以运算符也应该可以重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Vector2</span>(<span class="type">float</span> x, <span class="type">float</span> y) :<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Vector2 <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;x + other.x, y + other.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Vector2 <span class="title">Multiply</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;x * other.x, y * other.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Vector2 <span class="title">position</span><span class="params">(<span class="number">4.0f</span>, <span class="number">4.0f</span>)</span></span>;</span><br><span class="line">	<span class="function">Vector2 <span class="title">speed</span><span class="params">(<span class="number">0.5f</span>, <span class="number">1.5f</span>)</span></span>;</span><br><span class="line">	<span class="function">Vector2 <span class="title">powerup</span><span class="params">(<span class="number">1.1f</span>, <span class="number">1.1f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Vector2 result = position.<span class="built_in">Add</span>(speed.<span class="built_in">Multiply</span>(powerup));</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>

<p>我们想要实现这样的功能,但现在代码看上去有点难读,没关系,我们可以重载运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Vector2</span>(<span class="type">float</span> x, <span class="type">float</span> y) :<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Vector2 <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;x + other.x, y + other.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Vector2 <span class="keyword">operator</span>+(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Add</span>(other);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Vector2 <span class="title">Multiply</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;x * other.x, y * other.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Vector2 <span class="keyword">operator</span>*(<span class="type">const</span> Vector2&amp; other)<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Multiply</span>(other);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Vector2 <span class="title">position</span><span class="params">(<span class="number">4.0f</span>, <span class="number">4.0f</span>)</span></span>;</span><br><span class="line">	<span class="function">Vector2 <span class="title">speed</span><span class="params">(<span class="number">0.5f</span>, <span class="number">1.5f</span>)</span></span>;</span><br><span class="line">	<span class="function">Vector2 <span class="title">powerup</span><span class="params">(<span class="number">1.1f</span>, <span class="number">1.1f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Vector2 result = position + speed * powerup;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以这么写代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector2 <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span> + other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector2 <span class="keyword">operator</span>+(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; x + other.x, y + other.y &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者这么写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector2 <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">operator</span>+(other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector2 <span class="keyword">operator</span>+(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; x + other.x, y + other.y &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++有这样的语法,但在这这么写实在是太抽象了</p>
<hr>
<p>你也重载其他运算符,比如左移</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream,<span class="type">const</span> Vector2&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">	stream &lt;&lt; other.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; other.y;</span><br><span class="line">	<span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Vector2 <span class="title">position</span><span class="params">(<span class="number">4.0f</span>, <span class="number">4.0f</span>)</span></span>;</span><br><span class="line">	<span class="function">Vector2 <span class="title">speed</span><span class="params">(<span class="number">0.5f</span>, <span class="number">1.5f</span>)</span></span>;</span><br><span class="line">	<span class="function">Vector2 <span class="title">powerup</span><span class="params">(<span class="number">1.1f</span>, <span class="number">1.1f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Vector2 result = position + speed * powerup;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; result;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">4.55</span>,<span class="number">5.65</span></span><br></pre></td></tr></table></figure>

<h1 id="C-的this关键字"><a href="#C-的this关键字" class="headerlink" title="C++的this关键字"></a>C++的this关键字</h1><p>this是当前对象的指针,用于找到当前对象的实例</p>
<p>如果你在常量方法中访问this,它会是常量指针常量,在普通方法中,它会是指针</p>
<h1 id="C-对象的生存期"><a href="#C-对象的生存期" class="headerlink" title="C++对象的生存期"></a>C++对象的生存期</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Create Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		Entity e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">PLAINTEXT</span><br><span class="line">Create Entity!</span><br><span class="line">Destroyed Entity!</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Create Entity!</span><br></pre></td></tr></table></figure>

<p>以上是这次的重点,你需要分辨堆栈,理解栈上对象的生命周期</p>
<p>当栈上的对象离开栈作用域,对象会自动销毁</p>
<hr>
<p>现在,我还是希望在堆上创建对象,但我希望当对象超出作用域时销毁,我们这样编写一个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Create Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Entity* m_Ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ScopedPtr</span>(Entity* ptr):<span class="built_in">m_Ptr</span>(ptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_Ptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		ScopedPtr e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Create Entity!</span><br><span class="line">Destroyed Entity!</span><br></pre></td></tr></table></figure>

<h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h1><p>智能指针意味着,当你new了,你确不一定要delete,内存会在某个时候自动释放,比如unique指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::unique_ptr&lt;Entity&gt; entity = std::<span class="built_in">make_unique</span>&lt;Entity&gt;();</span><br><span class="line">		entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Created Entity!</span><br><span class="line">hello</span><br><span class="line">Destroyed Entity!</span><br></pre></td></tr></table></figure>

<p>你无法复制unique指针,它的拷贝构造函数和拷贝构造操作符被删除了,如果你想这个做,可以用share指针</p>
<p>share指针的工作方式是引用计数,跟踪你的指针有多少个引用,当引用数为0,对象被销毁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">		&#123;</span><br><span class="line">			std::shared_ptr&lt;Entity&gt; e0 = sharedEntity;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Created Entity!</span><br><span class="line">Destroyed Entity!</span><br></pre></td></tr></table></figure>

<p>你也可以结合weak指针,它可以幅值为share指针,但不会增加引用计数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::weak_ptr&lt;Entity&gt; e;</span><br><span class="line">		std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">		&#123;</span><br><span class="line">			std::shared_ptr&lt;Entity&gt; e0 = sharedEntity;</span><br><span class="line">			e = sharedEntity;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-的复制和拷贝构造函数"><a href="#C-的复制和拷贝构造函数" class="headerlink" title="C++的复制和拷贝构造函数"></a>C++的复制和拷贝构造函数</h1><p>我们写一个String类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_Buffer;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_Size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">		m_Buffer = <span class="keyword">new</span> <span class="type">char</span>[m_Size + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Buffer, string, m_Size + <span class="number">1</span>);</span><br><span class="line">		m_Buffer[m_Size] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">String</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] m_Buffer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream,<span class="type">const</span> String&amp; string)</span><br><span class="line">&#123;</span><br><span class="line">	stream &lt;&lt; string.m_Buffer;</span><br><span class="line">	<span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们做这样的操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	String string = <span class="string">&quot;Pditine&quot;</span>;</span><br><span class="line">	String second = string;</span><br><span class="line">	std::cout &lt;&lt; string &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你打断点一步步执行,你会发现,两个”Pditine”可以正常输出,但程序最后会报错</p>
<p>这是因为我们进行的是浅拷贝,这两个String的m_Buffer是相同的,当作用域到尽头,m_Buffer的空间会被释放两次</p>
<p>现在,我们为String写一个拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_Buffer;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_Size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">		m_Buffer = <span class="keyword">new</span> <span class="type">char</span>[m_Size + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Buffer, string, m_Size + <span class="number">1</span>);</span><br><span class="line">		m_Buffer[m_Size] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String&amp; other): <span class="built_in">m_Size</span>(other.m_Size)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Buffer = <span class="keyword">new</span> <span class="type">char</span>[m_Size + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Buffer, other.m_Buffer, m_Size + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">String</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] m_Buffer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream,<span class="type">const</span> String&amp; string)</span><br><span class="line">&#123;</span><br><span class="line">	stream &lt;&lt; string.m_Buffer;</span><br><span class="line">	<span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	String string = <span class="string">&quot;Pditine&quot;</span>;</span><br><span class="line">	String second = string;</span><br><span class="line">	std::cout &lt;&lt; string &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Pditine</span><br><span class="line">Pditine</span><br></pre></td></tr></table></figure>

<h1 id="C-的箭头操作符"><a href="#C-的箭头操作符" class="headerlink" title="C++的箭头操作符"></a>C++的箭头操作符</h1><p>当我们在使用指针,我们不想先逆向引用再调用对象内的东西,箭头操作符允许我们直接调用指针所代表的对象的成员</p>
<p>你可以重载箭头操作符来简化代码</p>
<p>你也可以写下这样的东西</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> offset = (<span class="type">int</span>)&amp;((Vector3*)<span class="literal">nullptr</span>)-&gt;x;</span><br><span class="line">	std::cout &lt;&lt; offset &lt;&lt; std::endl;</span><br><span class="line">	offset = (<span class="type">int</span>)&amp;((Vector3*)<span class="literal">nullptr</span>)-&gt;y;</span><br><span class="line">	std::cout &lt;&lt; offset &lt;&lt; std::endl;</span><br><span class="line">	offset = (<span class="type">int</span>)&amp;((Vector3*)<span class="literal">nullptr</span>)-&gt;z;</span><br><span class="line">	std::cout &lt;&lt; offset &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>这可以用来获取内存中某个值的偏移量</p>
<h1 id="C-的动态数组"><a href="#C-的动态数组" class="headerlink" title="C++的动态数组"></a>C++的动态数组</h1><p>Vector是C++模板库中的内容,虽然叫”向量”,实际上这是一个动态数组</p>
<p>Vector在内存中不是碎片,而是一条直线</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;Vertex&gt; vertices;</span><br><span class="line"></span><br><span class="line">	vertices.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">	vertices.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices.<span class="built_in">size</span>(); i++)</span><br><span class="line">		std::cout &lt;&lt; vertices[i].z;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> Vertex&amp; v : vertices)</span><br><span class="line">		std::cout &lt;&lt; v.x;</span><br><span class="line">    </span><br><span class="line">	vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-的stdvector使用优化"><a href="#C-的stdvector使用优化" class="headerlink" title="C++的stdvector使用优化"></a>C++的stdvector使用优化</h1><p>现在我们给Vertex写一个拷贝构造,观察Vertex何时被复制了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Vertex</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y),<span class="built_in">z</span>(z)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; vertex):<span class="built_in">x</span>(vertex.x),<span class="built_in">y</span>(vertex.y),<span class="built_in">z</span>(vertex.z)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;Vertex&gt; vertices;</span><br><span class="line"></span><br><span class="line">	vertices.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">	vertices.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;);</span><br><span class="line">	vertices.<span class="built_in">push_back</span>(&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br></pre></td></tr></table></figure>

<p>我们总共就加了三个元素,但这些元素进行了6次拷贝</p>
<p>首先,我们在栈上创建了Vertex(1,2,3),然后将它复制到vector的内存中,发生一次拷贝,此时vector的容量为1</p>
<p>然后,我们加入vertex(4,5,6),vector重新分配了一个有2容量的内存,并将两个元素复制到其中,发生两次拷贝</p>
<p>最后同理,加入vertex(7,8,9),vector重新分配了一个有3容量的内存,并将3个元素复制到其中,发生三次拷贝</p>
<p>这就是6次拷贝的来源,我们可以使vector的容量为3,或另一个个合适的数,这样就可以避免拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">	vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">	vertices.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">	vertices.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;);</span><br><span class="line">	vertices.<span class="built_in">push_back</span>(&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br></pre></td></tr></table></figure>

<p>成功了,但我们还可以做的更好,程序依然需要拷贝,这是因为我们始终在main函数的栈上创建元素,然后将元素复制到vector的内存中,我们可以使用emplace_back</p>
<p>这表示我们不是传递已经构造好的元素,而是传递构造函数的参数列表,然后直接在vector的内存中创建元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">	vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">	vertices.<span class="built_in">emplace_back</span>( <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> );</span><br><span class="line">	vertices.<span class="built_in">emplace_back</span>( <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> );</span><br><span class="line">	vertices.<span class="built_in">emplace_back</span>( <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> );</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>什么也没有输出,这正是我们想要的</p>
<h1 id="如何在C-中处理多返回值"><a href="#如何在C-中处理多返回值" class="headerlink" title="如何在C++中处理多返回值"></a>如何在C++中处理多返回值</h1><p>显然在默认情况下一个函数不能返回多个返回值</p>
<p>你可以通过返回数组或者vector返回相同类型的多个返回值</p>
<p>如果你想返回不同类型的值,你可以用下面的方法</p>
<ol>
<li>封装为结构体数据类来传递数据</li>
<li>通过指针或引用更改输入参数</li>
<li>返回Tuple或pair</li>
</ol>
<h1 id="C-的模板"><a href="#C-的模板" class="headerlink" title="C++的模板"></a>C++的模板</h1><p>如果你熟悉其他语言比如C#,你可以知道一个东西叫泛型</p>
<p>C++的模板和这个不是一回事,功能有类似,但不是一回事</p>
<p>模板有些像宏,不像泛型受制于类型系统或者别的因素,模板要强大的多</p>
<p>模板允许你给出一个代码实例,然后让编译器帮你写代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Print</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">	<span class="built_in">Print</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>当我们写下Print的时候,实际上这个函数并没有真的存在,而当我们调用函数的时候,基于我们传入的参数,这个函数会被创建出来</p>
<p>上面的例子是隐式的推断我们输入的类型,我们也可以显示的标记类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Print</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Print</span>&lt;std::string&gt;(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">	<span class="built_in">Print</span>&lt;<span class="type">bool</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>如果我从来没有调用Print,这个函数就根本不存在;当我们去掉Print的调用,并且制造一些语法错误,有些ide甚至不会给你报错</p>
<hr>
<p>我们也可以写和模板函数同名的函数,请注意我的函数写法与其输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>  T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt;<span class="string">&quot;int:&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Print</span>(<span class="number">1</span>);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="type">int</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Print</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<p>模板并不只基于函数,你也可以书写模板类</p>
<p>而且,你也可以将制定类型设为模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T ,<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T m_Array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> N;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Array&lt;<span class="type">int</span>,<span class="number">5</span>&gt; array;</span><br><span class="line">	std::cout &lt;&lt; array.<span class="built_in">GetSize</span>();</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>所以你大概能猜出C++的模板是如何工作的了,基本上,尖括号中每一项左边的部分是一种约定,typename意味着这里应该是一个类型名,int或者别的具体类型意味着这里应该是一个具体的元素,当你调用模板类或者模板函数的时候,你根据尖括号的约定来填空,然后C++将你填入的东西放到指定的位置,生成真正的代码</p>
<h1 id="C-堆与栈的比较"><a href="#C-堆与栈的比较" class="headerlink" title="C++堆与栈的比较"></a>C++堆与栈的比较</h1><p>当我们的程序开始的时候,内存被分成了许多区域,但我们只关心栈和堆,栈和堆是ram中实际存在的区域</p>
<p>在以下的例子中,上半部分的代码是在栈分配内存,下半部分的代码是在堆分配内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> array[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* hvalue = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	*hvalue = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span>* harray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>物理上,value和array的位置实际上很接近,因为当你在栈上分配多少字节,栈指针基本上就移动多少字节,当一个栈区域结束,意味着一些变量的生命结束,栈指针再移动回一定的字节</p>
<p>所以栈很快,因为栈将所有的东西都堆在一起,只是移动栈指针然后返回栈指针的地址</p>
<p>但hvalue和harray的物理位置很远,因为它们在堆中分配</p>
<p>你的程序维护一个叫free list的东西,它跟踪那些内存块是空闲的,在哪里等等,当你需要一个堆的内存,程序会浏览freelist,找到一个和我们要求的一样大的空闲的内存,然后返回这个内存的地址</p>
<p>总的来说,在堆中分配内存需要一堆事情,而在栈上分配内存只需要移动栈指针</p>
<h1 id="C-的宏"><a href="#C-的宏" class="headerlink" title="C++的宏"></a>C++的宏</h1><p>当编译C++代码时,代码会先过一遍预处理器,这是宏起作用的时候</p>
<p>我们希望做的,是使用宏将代码中的文本替换成其他的东西</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT std::cin.get()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WAIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这就是宏起作用的方式,但请注意,<strong>这不是好的代码</strong>,不要这么使用宏,如果宏定义在其他文件中,程序员会因为查找宏定义而头疼</p>
<p>我们不用将宏限制为完整的语句,它可以是任何东西,因为宏仅仅是文本替换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENDBRACE &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">ENDBRACE</span><br></pre></td></tr></table></figure>

<p>你也可以在宏中加”变量”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout&lt;&lt; x &lt;&lt;std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">LOG</span>(<span class="number">1</span>);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>你也可以写多行的宏,不必将一整个代码块都挤在同一行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN int main()\</span></span><br><span class="line"><span class="meta">	&#123;\</span></span><br><span class="line"><span class="meta">		std::cin.get();\</span></span><br><span class="line"><span class="meta">	&#125;\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">MAIN</span><br></pre></td></tr></table></figure>

<p>确保不要在反斜杠后面加空格</p>
<hr>
<p>现在我们举一个正常的宏使用场景</p>
<p>我们使用VS时,或许希望程序在debug模式下输出一些信息,但在release模式下不输出,因为我们不希望程序真正运行的时候还有额外的代码</p>
<p>此时我们可以在日志中使用宏</p>
<p>更改项目属性</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-14%20202722.png" alt="屏幕截图 2023-12-14 202722">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-12-14 202722.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout&lt;&lt; x &lt;&lt;std::endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">LOG</span>(<span class="number">1</span>);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时,当我们在debug模式下LOG才会起作用,而release模式下LOG会被直接删除,或者你也可以理解成替换为””</p>
<h1 id="C-中的auto关键字"><a href="#C-中的auto关键字" class="headerlink" title="C++中的auto关键字"></a>C++中的auto关键字</h1><p>到目前为止,我们虽然提及过类型是”虚假的”,只是一种标记,但我们也不能丢弃类型,因为类型确实让我们写代码的过程更高效了</p>
<p>但有时,我们获取不在乎某个值的类型,甚至仅仅不想思考它的类型,我们可以使用auto</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">auto</span> b = a;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>auto的使用很简单,就这样,原理也很简单,编辑器知道a的类型,或者在别的情况下,编辑器知道函数返回的类型,所以编辑器可以自行推断类型</p>
<p>然后让我们讨论一个问题:我们还要写类型吗,是不是可以所有能写auto的地方都写auto呢</p>
<p>如果是上面的例子,或者是<code>auto a = 5</code>,此时不要用auto,因为显示的写出类型可以让代码更清晰</p>
<p>但如果获取的值是一个函数的返回值,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Pditine&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> name = <span class="built_in">GetName</span>();</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就使用auto,因为一来,我们无法从代码文本中看出函数的返回值类型,二来,而如果API改变了返回值的类型,比如上面的例子函数的返回值改为char*,使用auto也不会出错</p>
<p>后者也是一种双刃剑,因为你可以无法发现API返回类型的改变而使强类型的功能出错,这里就具体情况具体分析了</p>
<p>总的来说,不使用auto没什么坏处,或者说总是知道你操作的类型没什么坏处</p>
<h1 id="C-静态数组"><a href="#C-静态数组" class="headerlink" title="C++静态数组"></a>C++静态数组</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::array&lt;<span class="type">int</span>, 5&gt; data;</span><br><span class="line">	data[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">	data[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	std::cout &lt;&lt; data[<span class="number">0</span>];</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>array的使用基本上和C风格的数组差不多</p>
<p>array是一个类,相比于C风格的数组,有许多拓展的功能,且内存原理基本上C数组相同,上面的例子中,array的内存存储在栈上(和vector不一样)</p>
<p>使用array有许多好处,比如在debug模式下的边界检查,直接返回的size等等,而且没有什么多于的内存开销,你应该到处使用array</p>
<h1 id="C-函数指针"><a href="#C-函数指针" class="headerlink" title="C++函数指针"></a>C++函数指针</h1><p>函数指针是一个将函数赋值给变量的方式,你可以它实现许多神奇的功能</p>
<p>本质上说,函数也是一堆0101,也存储在内存中,所以也有地址,有地址的东西就有指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloWorld</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello World! Value:&quot;</span>&lt;&lt;a&lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">void</span>(*function)(<span class="type">int</span>);</span><br><span class="line">	function = &amp;HelloWorld;</span><br><span class="line">	<span class="built_in">function</span>(<span class="number">5</span>);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后函数指针就不难理解了</p>
<h1 id="C-的lambda"><a href="#C-的lambda" class="headerlink" title="C++的lambda"></a>C++的lambda</h1><p>lambda是我们创建匿名函数的方式,在所以我们会设置函数指针的地方都可以使用lambda</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">void</span>(*func)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> value : values)</span><br><span class="line">		<span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="built_in">ForEach</span>(values, [](<span class="type">int</span> value) &#123;std::cout &lt;&lt; <span class="string">&quot;Value:&quot;</span> &lt;&lt; value &lt;&lt; std::endl; &#125;);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForEach的第二个参数是一个函数指针,意味着我们可以在这里写一个lambda</p>
<p>中括号中的内容表示捕获</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV195411A7KX/?spm_id_from=333.880.my_history.page.click&vd_source=4ec457bb4f6cbb496da2800adbe93b46">【59】【Cherno C++】【中字】C++的lambda_哔哩哔哩_bilibili</a></p>
<h1 id="为什么不使用namespace-std"><a href="#为什么不使用namespace-std" class="headerlink" title="为什么不使用namespace std"></a>为什么不使用namespace std</h1><p>当你加上了<code>using namespace std</code>,你就不需要在很多地方写<code>std::</code></p>
<p>但大部分情况你依然”需要”写<code>std::</code>,因为这样可以使你分清你使用的是标准库的东西还是别的地方的东西</p>
<p>同样,在多数情况下,你也需要写其他的<code>命名空间名::</code>来避免名称相同导致的错误</p>
<p>你可以仅仅在函数或者别的作用域中使用using nmaespace …,但不要在头文件中使用</p>
<h1 id="C-名称空间"><a href="#C-名称空间" class="headerlink" title="C++名称空间"></a>C++名称空间</h1><p>C++用命名空间来避免命名冲突</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> apple &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> orange&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text)</span></span>&#123;</span><br><span class="line">		std::string temp = text;</span><br><span class="line">		std::<span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">		std::cout &lt;&lt; temp &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	orange::<span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	apple::<span class="built_in">print</span>(<span class="string">&quot;hellp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以嵌套命名空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> apple &#123;<span class="keyword">namespace</span> function&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text)</span></span>&#123;</span><br><span class="line">		std::cout &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	orange::<span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	apple::function::<span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-线程"><a href="#C-线程" class="headerlink" title="C++线程"></a>C++线程</h1><p>我们以前写的代码都是单线程的</p>
<p>当我们进入到真正的工程中,常常需要使用多线程</p>
<p>比如,当我们在等待用户输入的时候,我们以前的代码是直接阻塞住,等待用户的输入</p>
<p>在等待用户输入的时候,我们就可以开一个线程做些其他的事情,比如记录什么</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> s_Finished = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;</span><br><span class="line">	<span class="keyword">while</span> (!s_Finished)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Working...\n&quot;</span>;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">worker</span><span class="params">(DoWork)</span></span>;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">	s_Finished = <span class="literal">true</span>;</span><br><span class="line">	worker.<span class="built_in">join</span>();</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-计时"><a href="#C-计时" class="headerlink" title="C++计时"></a>C++计时</h1><p>如果你希望某些事情在特定实践发生,那么你就需要计时</p>
<p>有几种方法可以实现</p>
<ol>
<li>C++11后C++库中的chrono</li>
<li>操作系统库API</li>
</ol>
<p>我们现在使用无关系统的C++库来实现</p>
<p>线程的睡眠实现可能不是你代码中写的精确的时间,计时本身也有时间开销</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">	<span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	std::chrono::duration&lt;<span class="type">float</span>&gt;duration = end - start;</span><br><span class="line"></span><br><span class="line">	std::cout&lt;&lt;duration.<span class="built_in">count</span>()&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">1.0067</span></span><br></pre></td></tr></table></figure>

<p>我们现在使用对象生命周期的原理实现一个计时器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line">	std::chrono::time_point&lt;std::chrono::steady_clock&gt; start,end;</span><br><span class="line">	std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Timer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Timer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">		duration = end - start;</span><br><span class="line">		<span class="type">float</span> ms = duration.<span class="built_in">count</span>()*<span class="number">1000.0f</span>;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;Timer took&quot;</span>&lt;&lt;ms&lt;&lt;<span class="string">&quot;ms&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Action</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;Hello&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Timer timer;</span><br><span class="line">	<span class="built_in">Action</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Timer took0<span class="number">.3052</span>ms</span><br></pre></td></tr></table></figure>

<p>我们还可以让它再快一点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Action</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;Hello\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Timer timer;</span><br><span class="line">	<span class="built_in">Action</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Timer took0<span class="number">.0964</span>ms</span><br></pre></td></tr></table></figure>

<p>既然你使用的是C++,你要想写更快的代码,你就要关心你的代码性能</p>
<h1 id="C-多维函数"><a href="#C-多维函数" class="headerlink" title="C++多维函数"></a>C++多维函数</h1><p>不要把多维数组看的太复杂,数组是数据的集合,所以2维数组是数组的集合,3维数组是2维数组的集合,以此类推</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span>** a2d = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span>*** a3d = <span class="keyword">new</span> <span class="type">int</span>**[<span class="number">50</span>];</span><br></pre></td></tr></table></figure>

<p>我们知道int的空间是4个字节,而类型是不重要的,所以这三行代码所做的事情是相同的,也就是分配200个字节</p>
<p>a2d里存储的是一堆地址,这些地址就可以代表数组第一个元素的位置</p>
<p>a3d里存储的还是一堆地址,这些地址可以代表一个二位数组第一个元素的位置</p>
<hr>
<p>如果这样分配内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>** a2d = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">		a2d[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会造成”内存碎片”问题,你的每个数组在内存中的位置不确定,可能很近也可能很远</p>
<p>当你从多维数组的一个元素跳到另一个元素,会造成cache miss</p>
<p>而我们完全可以用一个连续的内存存储数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>*<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-排序"><a href="#C-排序" class="headerlink" title="C++排序"></a>C++排序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> value:values)</span><br><span class="line">	std::cout&lt;&lt;value&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>我们也可以给排序一个谓词,让排序按照我们希望的方式进行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">// NOLINT(modernize-use-transparent-functors)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> value:values)</span><br><span class="line">	std::cout&lt;&lt;value&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a&lt;b;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> value:values)</span><br><span class="line">	std::cout&lt;&lt;value&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h1 id="C-的类型双关"><a href="#C-的类型双关" class="headerlink" title="C++的类型双关"></a>C++的类型双关</h1><p>C++是强类型的,C++有一个类型系统</p>
<p>但C++的类型限制不是那么强,至少没有java或者C#强,你可以直接访问内存</p>
<p>如果我们这样写代码,C++会进行隐式转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a =<span class="number">10</span>;</span><br><span class="line">	<span class="type">double</span> value = a;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在x86环境下观察到a的内存为<code>0a 00 00 00</code>,value的内存为<code>00 00 00 00 00 00 24 40</code></p>
<p>这说明隐式转换使数据内存数据在传递时发生了改变</p>
<p>如果我们这样写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a =<span class="number">10</span>;</span><br><span class="line">	<span class="type">double</span> value = *(<span class="type">double</span>*)&amp;a;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察到a的内存同上,value的内存为<code>0a 00 00 00 cc cc cc cc</code>,这说明作为double类型,它表示的数字是 <code>-9.2559592117432108e+61</code></p>
<p>这个例子进一步表明你可以在C++中绕过类型系统,直接控制内存</p>
<hr>
<p>我们还可以用更骚一点的方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity e = &#123;<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">int</span>* position = (<span class="type">int</span>*)&amp;e;</span><br><span class="line"></span><br><span class="line">	std::cout&lt;&lt;position[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;position[<span class="number">1</span>]&lt;&lt;std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">3</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h1 id="C-的联合体"><a href="#C-的联合体" class="headerlink" title="C++的联合体"></a>C++的联合体</h1><p>一个联合体可以有多个成员,但只占一个成员的内存</p>
<p>通常人们用联合体实现的功能和类型双关是紧密相关的</p>
<p>通常union是匿名使用的,但匿名union不能有成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Union</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">union</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">float</span> a;</span><br><span class="line">			<span class="type">int</span> b;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	Union u;</span><br><span class="line">	u.a = <span class="number">2.0f</span>;</span><br><span class="line">	std::cout&lt;&lt;u.a&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;u.b&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1073741824</span></span><br></pre></td></tr></table></figure>

<p>这就像是将一个float赋值为2.0f,然后将这个内存看成是int,这就是类型双关了</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">union</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">struct</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">float</span> x,y,z,w;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">struct</span> </span><br><span class="line">		&#123;</span><br><span class="line">			Vector2 a,b;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector2</span><span class="params">(<span class="type">const</span> Vector2&amp; vector2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;vector2.x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;vector2.y&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vector4  vector4 = &#123;<span class="number">1.0f</span>,<span class="number">2.0f</span>,<span class="number">3.0f</span>,<span class="number">4.0f</span>&#125;;</span><br><span class="line">	<span class="built_in">PrintVector2</span>(vector4.a);</span><br><span class="line">	vector4.z = <span class="number">100.0f</span>;</span><br><span class="line">	<span class="built_in">PrintVector2</span>(vector4.b);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="number">100</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>以上相当于我们可以用两个Vector2来组成Vector4,xyzw和ab所代表的内存是相同的</p>
<h1 id="C-虚析构函数"><a href="#C-虚析构函数" class="headerlink" title="C++虚析构函数"></a>C++虚析构函数</h1><p>我们现在做一个实验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Base() &#123;std::cout&lt;&lt;&quot;Base Constructor\n&quot;; &#125;</span><br><span class="line">	~Base()&#123; std::cout&lt;&lt;&quot;Base Destructor\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived:public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Derived() &#123; std::cout &lt;&lt; &quot;Derived Constructor\n&quot;; &#125;</span><br><span class="line">	~Derived() &#123; std::cout &lt;&lt; &quot;Derived Destructor\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Base* base = new Base;</span><br><span class="line">	delete base;</span><br><span class="line">	std::cout&lt;&lt;&quot;------------------&quot;&lt;&lt;std::endl;</span><br><span class="line">	Derived* derived = new Derived;</span><br><span class="line">	delete derived;</span><br><span class="line"></span><br><span class="line">	std::cin.get();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Base Constructor</span><br><span class="line">Base Destructor</span><br><span class="line">------------------</span><br><span class="line">Base Constructor</span><br><span class="line">Derived Constructor</span><br><span class="line">Derived Destructor</span><br><span class="line">Base Destructor</span><br></pre></td></tr></table></figure>

<p>我们发现当我调用子类的构造和析构,也会按一定的顺序调用父类的构造和析构</p>
<p>但如果我们使用多态指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Base* base = new Base;</span><br><span class="line">	delete base;</span><br><span class="line">	std::cout&lt;&lt;&quot;------------------&quot;&lt;&lt;std::endl;</span><br><span class="line">	Derived* derived = new Derived;</span><br><span class="line">	delete derived;</span><br><span class="line">	std::cout &lt;&lt; &quot;------------------&quot; &lt;&lt; std::endl;</span><br><span class="line">	Base* poly = new Derived;</span><br><span class="line">	delete poly;</span><br><span class="line">	std::cin.get();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Base Constructor</span><br><span class="line">Base Destructor</span><br><span class="line">------------------</span><br><span class="line">Base Constructor</span><br><span class="line">Derived Constructor</span><br><span class="line">Derived Destructor</span><br><span class="line">Base Destructor</span><br><span class="line">------------------</span><br><span class="line">Base Constructor</span><br><span class="line">Derived Constructor</span><br><span class="line">Base Destructor</span><br></pre></td></tr></table></figure>

<p>我们可以看到父类和子类的构造都正常调用了,但子类的析构没有调用,这会导致内存泄漏,因为父类的析构无法删除子类新成员占有的内存</p>
<p>在使用虚函数时,我们给父类的函数加上virtual,意味着有可能会有子类复写这个函数</p>
<p>但我们给析构加上virtual,意味着当使用多态指针调用析构,我们将会调用子类和父类的析构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Base() &#123;std::cout&lt;&lt;&quot;Base Constructor\n&quot;; &#125;</span><br><span class="line">	virtual ~Base()&#123; std::cout&lt;&lt;&quot;Base Destructor\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived:public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int* a;</span><br><span class="line">	Derived()</span><br><span class="line">	&#123;</span><br><span class="line">		a = new int[3];</span><br><span class="line">		std::cout &lt;&lt; &quot;Derived Constructor\n&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	~Derived()</span><br><span class="line">	&#123;</span><br><span class="line">		delete[] a;</span><br><span class="line">		std::cout &lt;&lt; &quot;Derived Destructor\n&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Base* base = new Base;</span><br><span class="line">	delete base;</span><br><span class="line">	std::cout&lt;&lt;&quot;------------------&quot;&lt;&lt;std::endl;</span><br><span class="line">	Derived* derived = new Derived;</span><br><span class="line">	delete derived;</span><br><span class="line">	std::cout &lt;&lt; &quot;------------------&quot; &lt;&lt; std::endl;</span><br><span class="line">	Base* poly = new Derived;</span><br><span class="line">	delete poly;</span><br><span class="line">	std::cin.get();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line">Base Constructor</span><br><span class="line">Base Destructor</span><br><span class="line">------------------</span><br><span class="line">Base Constructor</span><br><span class="line">Derived Constructor</span><br><span class="line">Derived Destructor</span><br><span class="line">Base Destructor</span><br><span class="line">------------------</span><br><span class="line">Base Constructor</span><br><span class="line">Derived Constructor</span><br><span class="line">Derived Destructor</span><br><span class="line">Base Destructor</span><br></pre></td></tr></table></figure>

<h1 id="C-的类型转换"><a href="#C-的类型转换" class="headerlink" title="C++的类型转换"></a>C++的类型转换</h1><p>之前我们已经提及了类型转换</p>
<p>我们可以使用多种方法进行强制类型转换</p>
<p>C风格方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> value = <span class="number">4.55</span>;</span><br><span class="line">	<span class="type">int</span> a = (<span class="type">int</span>)value;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++风格方法</p>
<p>C++方法不会实现任何C方法不能做的功能,你可以理解只是一些语法糖</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>` `<span class="keyword">reinterpret_cast</span>` `<span class="keyword">const_cast</span>` `<span class="keyword">dynamic_cast</span></span><br></pre></td></tr></table></figure>

<p>如果你想要使转换之后的内存适应新的类型,你可以用static_cast</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> value = <span class="number">4.55</span>;</span><br><span class="line">	<span class="type">int</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(value);</span><br><span class="line">	std::cout&lt;&lt;a;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line">SHELL</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h1 id="条件与断点"><a href="#条件与断点" class="headerlink" title="条件与断点"></a>条件与断点</h1><h1 id="C-中的安全"><a href="#C-中的安全" class="headerlink" title="C++中的安全"></a>C++中的安全</h1><p>C++的安全问题大多数来源于指针和内存</p>
<p>我们先说内存,常见的问题是内存泄漏,比如你使用了堆的空间,但忘了清空,此处就出现了内存泄漏</p>
<p>这可以是无害的,也可能是灾难性的</p>
<p>以及内存所有权问题</p>
<p>如果你有一个原始指针,但你将它作为参数传输了出去,两个指针都有了这个内存的引用,那么内存的所有权属于谁呢</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">kaka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/13/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2023/08/13/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">KAKA的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/cover/c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/09/shader%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%E2%80%94%E2%80%94CurvedWorld/" title="shader学习实例——CurvedWorld"><img class="cover" src="/cover/shader.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">shader学习实例——CurvedWorld</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据结构与算法学习笔记"><img class="cover" src="/cover/datastruct.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构与算法学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kaka</div><div class="author-info__description">还在新手期的游戏开发爱好者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">卡卡立志成为技术宅地下偶像，欢迎来到我的个人博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0C"><span class="toc-number">1.</span> <span class="toc-text">欢迎来到C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8Windows%E4%B8%8A%E5%AE%89%E8%A3%85C"><span class="toc-number">2.</span> <span class="toc-text">在Windows上安装C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">C++是如何工作的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">C++源文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">main函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">3.2.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">3.3.</span> <span class="toc-text">链接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%BC%96%E8%AF%91%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">4.</span> <span class="toc-text">C++编译器是如何工作的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86-1"><span class="toc-number">4.1.</span> <span class="toc-text">预处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91-1"><span class="toc-number">4.2.</span> <span class="toc-text">编译</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E9%93%BE%E6%8E%A5%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">5.</span> <span class="toc-text">C++链接器是如何工作的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%8F%98%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">C++变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">C++函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">C++头文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Visual-Studio%E4%B8%AD%E8%B0%83%E8%AF%95"><span class="toc-number">9.</span> <span class="toc-text">如何在Visual Studio中调试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%88%86%E6%94%AF"><span class="toc-number">10.</span> <span class="toc-text">C++条件与分支</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%BE%AA%E7%8E%AF"><span class="toc-number">11.</span> <span class="toc-text">C++循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5"><span class="toc-number">12.</span> <span class="toc-text">C++控制流语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%8C%87%E9%92%88"><span class="toc-number">13.</span> <span class="toc-text">C++指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%BC%95%E7%94%A8"><span class="toc-number">14.</span> <span class="toc-text">C++引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">C++类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">16.</span> <span class="toc-text">C++类与结构体的对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAC-%E7%B1%BB"><span class="toc-number">17.</span> <span class="toc-text">如何写一个C++类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81"><span class="toc-number">18.</span> <span class="toc-text">C++中的静态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%96%E4%BD%BF%E7%94%A8%E7%9A%84static"><span class="toc-number">18.1.</span> <span class="toc-text">在类和结构体外使用的static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E4%BD%BF%E7%94%A8%E7%9A%84static"><span class="toc-number">18.2.</span> <span class="toc-text">在类和结构体内使用的static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81"><span class="toc-number">18.3.</span> <span class="toc-text">C++中的局部静态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%9E%9A%E4%B8%BE"><span class="toc-number">19.</span> <span class="toc-text">C++枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">20.</span> <span class="toc-text">C++构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">21.</span> <span class="toc-text">C++析构函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%BB%A7%E6%89%BF"><span class="toc-number">22.</span> <span class="toc-text">C++继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">23.</span> <span class="toc-text">C++虚函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">24.</span> <span class="toc-text">C++纯虚函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">25.</span> <span class="toc-text">C++可见性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%95%B0%E7%BB%84"><span class="toc-number">26.</span> <span class="toc-text">C++数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">27.</span> <span class="toc-text">C++字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">28.</span> <span class="toc-text">C++字符串字面量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84Const"><span class="toc-number">29.</span> <span class="toc-text">C++中的Const</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84mutable%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">30.</span> <span class="toc-text">C++的mutable关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">31.</span> <span class="toc-text">C++的成员初始化列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">32.</span> <span class="toc-text">C++中的三元操作符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96C-%E5%AF%B9%E8%B1%A1"><span class="toc-number">33.</span> <span class="toc-text">创建并初始化C++对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84new%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">34.</span> <span class="toc-text">C++中的new关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E9%9A%90%E5%BC%8F%E8%A3%85%E6%8D%A2%E4%B8%8Eexplicit%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">35.</span> <span class="toc-text">C++隐式装换与explicit关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E9%87%8D%E8%BD%BD"><span class="toc-number">36.</span> <span class="toc-text">C++运算符及其重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">37.</span> <span class="toc-text">C++的this关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">38.</span> <span class="toc-text">C++对象的生存期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">39.</span> <span class="toc-text">C++智能指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">40.</span> <span class="toc-text">C++的复制和拷贝构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E7%AE%AD%E5%A4%B4%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">41.</span> <span class="toc-text">C++的箭头操作符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">42.</span> <span class="toc-text">C++的动态数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84stdvector%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-number">43.</span> <span class="toc-text">C++的stdvector使用优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8C-%E4%B8%AD%E5%A4%84%E7%90%86%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">44.</span> <span class="toc-text">如何在C++中处理多返回值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="toc-number">45.</span> <span class="toc-text">C++的模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">46.</span> <span class="toc-text">C++堆与栈的比较</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E5%AE%8F"><span class="toc-number">47.</span> <span class="toc-text">C++的宏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84auto%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">48.</span> <span class="toc-text">C++中的auto关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">49.</span> <span class="toc-text">C++静态数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">50.</span> <span class="toc-text">C++函数指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84lambda"><span class="toc-number">51.</span> <span class="toc-text">C++的lambda</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8namespace-std"><span class="toc-number">52.</span> <span class="toc-text">为什么不使用namespace std</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">53.</span> <span class="toc-text">C++名称空间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%BA%BF%E7%A8%8B"><span class="toc-number">54.</span> <span class="toc-text">C++线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%AE%A1%E6%97%B6"><span class="toc-number">55.</span> <span class="toc-text">C++计时</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%A4%9A%E7%BB%B4%E5%87%BD%E6%95%B0"><span class="toc-number">56.</span> <span class="toc-text">C++多维函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%8E%92%E5%BA%8F"><span class="toc-number">57.</span> <span class="toc-text">C++排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%8C%E5%85%B3"><span class="toc-number">58.</span> <span class="toc-text">C++的类型双关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-number">59.</span> <span class="toc-text">C++的联合体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">60.</span> <span class="toc-text">C++虚析构函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">61.</span> <span class="toc-text">C++的类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E6%96%AD%E7%82%B9"><span class="toc-number">62.</span> <span class="toc-text">条件与断点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8"><span class="toc-number">63.</span> <span class="toc-text">C++中的安全</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/09/shader%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%E2%80%94%E2%80%94CurvedWorld/" title="shader学习实例——CurvedWorld"><img src="/cover/shader.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shader学习实例——CurvedWorld"/></a><div class="content"><a class="title" href="/2024/03/09/shader%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%E2%80%94%E2%80%94CurvedWorld/" title="shader学习实例——CurvedWorld">shader学习实例——CurvedWorld</a><time datetime="2024-03-09T11:31:38.000Z" title="发表于 2024-03-09 19:31:38">2024-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/13/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C++学习笔记"><img src="/cover/c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++学习笔记"/></a><div class="content"><a class="title" href="/2023/08/13/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C++学习笔记">C++学习笔记</a><time datetime="2023-08-13T15:35:54.000Z" title="发表于 2023-08-13 23:35:54">2023-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据结构与算法学习笔记"><img src="/cover/datastruct.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法学习笔记"/></a><div class="content"><a class="title" href="/2023/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据结构与算法学习笔记">数据结构与算法学习笔记</a><time datetime="2023-07-09T14:56:41.000Z" title="发表于 2023-07-09 22:56:41">2023-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By kaka</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>