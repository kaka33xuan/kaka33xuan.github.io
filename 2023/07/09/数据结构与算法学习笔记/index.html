<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法学习笔记 | KAKA的个人博客</title><meta name="author" content="kaka"><meta name="copyright" content="kaka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="程序&#x3D;数据结构+算法">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法学习笔记">
<meta property="og:url" content="http://example.com/2023/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="KAKA的个人博客">
<meta property="og:description" content="程序&#x3D;数据结构+算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/cover/datastruct.jpg">
<meta property="article:published_time" content="2023-07-09T14:56:41.000Z">
<meta property="article:modified_time" content="2024-05-09T16:04:39.343Z">
<meta property="article:author" content="kaka">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/cover/datastruct.jpg"><link rel="shortcut icon" href="/img/KA.png"><link rel="canonical" href="http://example.com/2023/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-10 00:04:39'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/cover/datastruct.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="KAKA的个人博客"><span class="site-name">KAKA的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-09T14:56:41.000Z" title="发表于 2023-07-09 22:56:41">2023-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-09T16:04:39.343Z" title="更新于 2024-05-10 00:04:39">2024-05-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的实现--静态分配</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType Data[MAX_SIZE];</span><br><span class="line">	<span class="type">int</span> Length;</span><br><span class="line">&#125; SQList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作--初始化一个顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SQList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">		L.Data[i] = <span class="number">0</span>;</span><br><span class="line">	L.Length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SQList L;</span><br><span class="line">	<span class="built_in">InitList</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的实现--动态分配</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType* data;</span><br><span class="line">	<span class="type">int</span> MaxSize;</span><br><span class="line">	<span class="type">int</span> Length;</span><br><span class="line">&#125; SeqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(InitSize * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	L.Length = <span class="number">0</span>;</span><br><span class="line">	L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = L.data;</span><br><span class="line">	L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>((L.MaxSize + len) * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.Length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.data[i] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	L.MaxSize = L.MaxSize + len;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态分配的插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListInsert</span><span class="params">(SQList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j=L.Length;j&gt;=i;j--)</span><br><span class="line">		L.Data[j] = L.Data[j - <span class="number">1</span>];</span><br><span class="line">	L.Data[i - <span class="number">1</span>] = e;</span><br><span class="line">	L.Length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态分配的插入改进</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SQList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.Length + <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (L.Length &gt;= MAX_SIZE)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=L.Length;j&gt;=i;j--)</span><br><span class="line">		L.Data[j] = L.Data[j - <span class="number">1</span>];</span><br><span class="line">	L.Data[i - <span class="number">1</span>] = e;</span><br><span class="line">	L.Length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态分配的删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SQList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.Length)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	e = L.Data[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; L.Length; j++)</span><br><span class="line">		L.Data[j - <span class="number">1</span>] = L.Data[j];</span><br><span class="line">	L.Length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SQList L,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L.Data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SeqList L,<span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.Length; i++)</span><br><span class="line">		<span class="keyword">if</span> (L.Data[i] == e)<span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType Data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span>* next;</span><br><span class="line">&#125;LNode, * LinkList;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按位插入"><a href="#按位插入" class="headerlink" title="按位插入"></a>按位插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位插入</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode* p = L;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">	s-&gt;Data = e;</span><br><span class="line">	s-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后插操作"><a href="#后插操作" class="headerlink" title="后插操作"></a>后插操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后插操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InserNextNode</span><span class="params">(LNode *p,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	s-&gt;Data = e;</span><br><span class="line">	s-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前插操作"><a href="#前插操作" class="headerlink" title="前插操作"></a>前插操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	s-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	s-&gt;Data = p-&gt;Data;</span><br><span class="line">	p-&gt;Data = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><h4 id="按位删除"><a href="#按位删除" class="headerlink" title="按位删除"></a>按位删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode* p = L;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode* q = p-&gt;next;</span><br><span class="line">	e = q-&gt;Data;</span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指定节点删除"><a href="#指定节点删除" class="headerlink" title="指定节点删除"></a>指定节点删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定节点删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode* q = p-&gt;next;</span><br><span class="line">	p-&gt;Data = p-&gt;next-&gt;Data;</span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找</span></span><br><span class="line"><span class="function">LNode * <span class="title">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	LNode* p=L;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function">LNode* <span class="title">LocateElem</span><span class="params">(LinkList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode* p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;Data != e)</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">DNode</span>* prior, * next;</span><br><span class="line">&#125;DNode,*DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L = (DNode*)<span class="built_in">malloc</span>((<span class="built_in">sizeof</span>(DNode)));</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p,DNode *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	s-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">		p-&gt;next-&gt;prior = s;</span><br><span class="line">	s-&gt;prior = p;</span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	DNode* q = p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (q == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">		q-&gt;next-&gt;prior = p;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="整表删除"><a href="#整表删除" class="headerlink" title="整表删除"></a>整表删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryList</span><span class="params">(DLinklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">DeleteNextDNode</span>(L);</span><br><span class="line">	<span class="built_in">free</span>(L);</span><br><span class="line">	L = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="前项遍历"><a href="#前项遍历" class="headerlink" title="前项遍历"></a>前项遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(P!=<span class="literal">NULL</span>)</span><br><span class="line">    p=p-&gt;next;</span><br></pre></td></tr></table></figure>

<h4 id="后项遍历"><a href="#后项遍历" class="headerlink" title="后项遍历"></a>后项遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(P!=<span class="literal">NULL</span>)</span><br><span class="line">    p=p-&gt;prior;</span><br></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span>* next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	L-&gt;next = L;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环单链表判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == L)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断P是否为表尾节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTail</span><span class="params">(LinkList L, LNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;next == L)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">DNode</span> *prior, *next;</span><br><span class="line">&#125;DNode,*DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinklist L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L = (DNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	L-&gt;prior = L;</span><br><span class="line">	L-&gt;next = L;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p,DNode *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	s-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next-&gt;prior = s;</span><br><span class="line">	s-&gt;prior = p;</span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;	</span><br><span class="line">	ElemType data;	</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是只允许在一段进行插入或删除操作的线性表</p>
<h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">my_struct</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	S.top = S.top + <span class="number">1</span>;</span><br><span class="line">	S.data[S.top] = x;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x = S.data[S.top];</span><br><span class="line">	S.top = S.top - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取栈顶元素"><a href="#获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack&amp; S, ElemType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x = S.data[S.top];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="*共享栈"></a>*共享栈</h3><p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-25%20232655.png" alt="屏幕截图 2023-07-25 232655"></p>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>略</p>
<h3 id="判断输出序列的合法性"><a href="#判断输出序列的合法性" class="headerlink" title="判断输出序列的合法性"></a>判断输出序列的合法性</h3><p>如果一个节点已经弹出,那么它之后弹出的比它先压入栈的节点一定按照顺序出栈</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是只允许在一段进行插入,在另一端删除的线性表</p>
<p>所以队列是先进先出的</p>
<p>First In First Out(FIFO)</p>
<h3 id="顺序存储结构-1"><a href="#顺序存储结构-1" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((Q.rear+<span class="number">1</span>)%MaxSize==Q.front)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	Q.data[Q.rear] = x;</span><br><span class="line">	Q.rear = (Q.rear + <span class="number">1</span>)%MaxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x = Q.data[Q.front];</span><br><span class="line">	Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查看队头"><a href="#查看队头" class="headerlink" title="查看队头"></a>查看队头</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue&amp; Q, ElemType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x = Q.data[Q.front];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他判断队满的办法"><a href="#其他判断队满的办法" class="headerlink" title="*其他判断队满的办法"></a>*其他判断队满的办法</h4><h3 id="链式存储结构-带头结点"><a href="#链式存储结构-带头结点" class="headerlink" title="链式存储结构(带头结点)"></a>链式存储结构(带头结点)</h3><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkNode</span>* next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">	LinkNode* front, * rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">	Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkNode* s = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">	s-&gt;data = x;</span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	Q.rear-&gt;next = s;</span><br><span class="line">	Q.rear = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LinkNode* p = Q.front-&gt;next;</span><br><span class="line">	x = p-&gt;data;</span><br><span class="line">	Q.front-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (Q.rear == p)</span><br><span class="line">		Q.rear = Q.front;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列是允许从两端插入和删除的线性表</p>
<p>判断输出序列合法性</p>
<p>如果一个序列在栈中合法,那么在双端序列中一定合法</p>
<h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><ul>
<li><p>树的层次遍历</p>
</li>
<li><p>图的广度优先遍历</p>
</li>
<li><p>队列在操作系统中的应用:</p>
<p>FCFS(first come first service)的策略轮流服务进程</p>
</li>
</ul>
<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p>串就是存储字符的线性表</p>
<h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态数组实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch[MAXLEN];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>

<h3 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SubString</span> <span class="params">(SString &amp;Sub,SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos + len - <span class="number">1</span> &gt; S.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; pos + len; i++)</span><br><span class="line">		Sub.ch[i - pos+<span class="number">1</span>] = S.ch[i];</span><br><span class="line">	Sub.length = len;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="比较两个串的大小"><a href="#比较两个串的大小" class="headerlink" title="比较两个串的大小"></a>比较两个串的大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrCompare</span><span class="params">(SString S,SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=S.length&amp;&amp;i&lt;=T.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (S.ch[i] != T.ch[i])</span><br><span class="line">			<span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S,SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>, n = <span class="built_in">StrLength</span>(S), m = <span class="built_in">StrLength</span>(T);</span><br><span class="line">	SString sub;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;= n-m+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SubString</span>(sub, S, i, m);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">StrCompare</span>(sub, T) != <span class="number">0</span>)++i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StringNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">StringNode</span>* next;</span><br><span class="line">&#125;StringNode,*String;</span><br></pre></td></tr></table></figure>

<p>ch作为数组旨在提高存储密度</p>
<h2 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h2><p>匹配一定长度的模式串,将主串中所有长度和模式串的子串和模式串比较,直到找到一个完全匹配的子串或所有的子串都不匹配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S,SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;=S.length&amp;&amp;j&lt;=T.length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(S.ch[i]==T.ch[j])</span><br><span class="line">		&#123;</span><br><span class="line">			++i; ++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			i = i - j + <span class="number">2</span>;</span><br><span class="line">			j = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j &gt; T.length)</span><br><span class="line">		<span class="keyword">return</span> i - T.length;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏时间复杂度:O(nm)</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-01%20193415.png" alt="屏幕截图 2023-08-01 193415"></p>
<p>在这种情况下,查找到模式串第六个字符才发现不匹配,那么主串的前几个子串都不匹配,可以直接从下图的位置继续匹配</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-01%20193615.png" alt="屏幕截图 2023-08-01 193615"></p>
<p>对于这个例子,当出现这种情况,可以使i不变,j&#x3D;3继续匹配</p>
<p>那么如果第五个元素匹配失败,可以使i不变,j&#x3D;2继续匹配</p>
<p>也就是说,对于某个特定的模式串,某位位数不是1的字符如果匹配失败,可以使i不变,j赋给某个值继续匹配来节省计算</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-02%20010317.png" alt="屏幕截图 2023-08-02 010317"></p>
<p>这个思想只和子串的内容有关系,和主串没有关系,也就是说,主串指针i不需要回溯</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;=S.length&amp;&amp;j&lt;=T.length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">0</span> || S.ch[i] == T.ch[j])</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j = next[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j &gt; T.length)</span><br><span class="line">		<span class="keyword">return</span> i - T.length;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1b7411N798/?p=37&vd_source=4ec457bb4f6cbb496da2800adbe93b46">4.2_3_求next数组_哔哩哔哩_bilibili</a></p>
<h3 id="next数组的优化"><a href="#next数组的优化" class="headerlink" title="next数组的优化"></a>next数组的优化</h3><p>在下面的例子中,j&#x3D;3时匹配失败,应该使j&#x3D;1</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-04%20140711.png" alt="屏幕截图 2023-08-04 140711"></p>
<p>但我们可以发现,模式串的第一个和第三个字符都是a,所以i&#x3D;3,j&#x3D;1进行的匹配一定失败</p>
<p>因此,最好的方式是将next[3]&#x3D;0,同理也应该使next[5]&#x3D;1</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-04%20141147.png" alt="屏幕截图 2023-08-04 141147"></p>
<p>这样得到的数组叫nextval数组</p>
<h3 id="求nextval数组"><a href="#求nextval数组" class="headerlink" title="求nextval数组"></a>求nextval数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">2</span>;j&lt;=T.length;j++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T.ch[next[j]] == T.ch[j])</span><br><span class="line">		nextval[j] = nextval[next[j]];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		nextval[j] = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的定义和基本术语"><a href="#树的定义和基本术语" class="headerlink" title="树的定义和基本术语"></a>树的定义和基本术语</h2><ul>
<li><p>非空树的特性：</p>
<p>有且仅有一个根结点</p>
<p>没有后继的结点称为“叶子结点”</p>
<p>有后继的结称为“分支结点”</p>
<p>除了根结点外，任何一个结点都<strong>有且仅有</strong>一个前驱</p>
<p>每个结点可以有0个或者多个后继。</p>
<p>空树是指结点为0的树</p>
</li>
<li><p>树的基本概念</p>
<p>树是n（n&gt;0）个结点的有限集合，n&#x3D; 0时，称为空树，这是一种特殊情况。在任意一棵非空树应满足：</p>
<ul>
<li>有且仅有一个特定的称为根的结点。</li>
<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集合T1，T2，…，Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。</li>
</ul>
</li>
<li><p>结点、树的属性描述</p>
<ul>
<li><p>结点的层次（深度）——从上往下数</p>
</li>
<li><p>结点的高度——从上往下数</p>
</li>
<li><p>树的高度（深度）——总共多少层</p>
</li>
<li><p><strong>结点的度</strong>——有几个孩子（分支）</p>
</li>
<li><p><strong>树的度</strong>——各结点的度的最大值</p>
</li>
</ul>
</li>
<li><p>有序树和无序树</p>
<ul>
<li><p>有序树——逻辑上看，树中结点的各子树从左至右是有次序的，不能互换</p>
</li>
<li><p>无序树——逻辑上看，树中结点的个子树从左至右是无次序的，可以互换</p>
</li>
</ul>
</li>
<li><p>树和森林</p>
<ul>
<li>森林是m（m&gt;0) 棵互不相交的树的集合</li>
</ul>
</li>
</ul>
<h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><p>树的结点数为总度数+1</p>
<p>度为m的树第i层至多有m^i-1个结点</p>
<p>高度为h的m叉树至多有(m^h-1)&#x2F;m-1和结点</p>
<p>高度为h的m叉树至少有h个结点</p>
<p>高度为h,度为m的数至少有h+m-1个结点</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>二叉树是n(n&gt;&#x3D;0)个结点的有限集合：</p>
<p>空二叉树，n&#x3D;0</p>
<p>由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</p>
<p>每个结点至多只有两棵子树，左右字数不能颠倒（二叉树是有序树）</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20183346.png" alt="屏幕截图 2023-08-05 183346">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-05 183346.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20183907.png" alt="屏幕截图 2023-08-05 183907">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-05 183907.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20184211.png" alt="屏幕截图 2023-08-05 184211"></p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20184437.png" alt="屏幕截图 2023-08-05 184437">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-05 184437.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20184539.png" alt="屏幕截图 2023-08-05 184539">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-05 184539.png)</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20184545.png" alt="屏幕截图 2023-08-05 184545"></p>
<h3 id="完全二叉树的性质"><a href="#完全二叉树的性质" class="headerlink" title="完全二叉树的性质"></a>完全二叉树的性质</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20184741.png" alt=" ">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-05 184741.png)</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20185509.png" alt="屏幕截图 2023-08-05 185509"></p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储-1"><a href="#顺序存储-1" class="headerlink" title="顺序存储"></a>顺序存储</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType value;</span><br><span class="line">	<span class="type">bool</span> isEmpty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是完全二叉树的顺序存储</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20185906.png" alt="屏幕截图 2023-08-05 185906"></p>
<p>将普通二叉树的编号和完全二叉树对应,就可以顺序存储普通二叉树</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20190107.png" alt="屏幕截图 2023-08-05 190107"></p>
<p>对于普通二叉树的顺序存储,判断二叉树的结点是否有左&#x2F;右子时,需要使用变量isEmpty判断</p>
<p>这种方法存储的二叉树可能有大量的内存浪费</p>
<h4 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild,*rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20190605.png" alt="屏幕截图 2023-08-05 190605"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild,*rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line">BiTree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根结点</span></span><br><span class="line">	root = (BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">	root-&gt;data = <span class="number">1</span>;</span><br><span class="line">	root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">	BiTNode* p = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">	p-&gt;data = <span class="number">2</span>;</span><br><span class="line">	p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	root-&gt;lchild = p;</span><br></pre></td></tr></table></figure>

<p>还有三叉链表式的定义,便于查找父结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild,*rchild;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiTNode</span>* parent;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的先-中-后序遍历"><a href="#二叉树的先-中-后序遍历" class="headerlink" title="二叉树的先&#x2F;中&#x2F;后序遍历"></a>二叉树的先&#x2F;中&#x2F;后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">visit</span>(T);</span><br><span class="line">		<span class="built_in">PreOrder</span>(T-&gt;lchild);</span><br><span class="line">		<span class="built_in">PreOrder</span>(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">InOrder</span>(T-&gt;lchild);</span><br><span class="line">		<span class="built_in">visit</span>(T);</span><br><span class="line">		<span class="built_in">InOrder</span>(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">PostOrder</span>(T-&gt;lchild);</span><br><span class="line">		<span class="built_in">PostOrder</span>(T-&gt;rchild);</span><br><span class="line">		<span class="built_in">visit</span>(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用:求树的深度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">treeDepth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> l = <span class="built_in">treeDepth</span>(T-&gt;lchild);</span><br><span class="line">	<span class="type">int</span> r = <span class="built_in">treeDepth</span>(T-&gt;rchild);</span><br><span class="line">	<span class="keyword">return</span> l &gt; r ? l + <span class="number">1</span> : r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p>一层一层的遍历</p>
<p>用一个辅助队列,根节点入队,若队列非空,队头出队,访问队头,队头节点的左右子依次入队,直至队列为空</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20205231.png" alt="屏幕截图 2023-08-05 205231"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkQueue Q;</span><br><span class="line">	<span class="built_in">InitQueue</span>(Q);</span><br><span class="line">	BiTree p;</span><br><span class="line">	<span class="built_in">EnQueue</span>(Q, T);</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DeQueue</span>(Q, p);</span><br><span class="line">		<span class="built_in">visit</span>(p);</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">EnQueue</span>(Q, p-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">EnQueue</span>(Q, p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h3><p>只给定一个遍历序列,不能确定唯一的二叉树</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20205749.png" alt="屏幕截图 2023-08-05 205749"></p>
<p>必须至少给出以下三种组合中的一种才能确定唯一的二叉树</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20205913.png" alt="屏幕截图 2023-08-05 205913"></p>
<p>e.g.</p>
<p><img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20210248.png" alt="屏幕截图 2023-08-05 210248"></p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>二插链表存储的二叉树的叶结点的左右指针为空,我们可以让这些指针指向结点的前驱和后继,从而使二叉树获得一些性质</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20160224.png" alt="屏幕截图 2023-08-06 160224">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-06 160224.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ThreadNode</span>* lchild, * rchild;</span><br><span class="line">	<span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure>

<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20160654.png" alt="屏幕截图 2023-08-06 160654">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-06 160654.png)</p>
<h4 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为中序线索化</span></span><br><span class="line">ThreadNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pre = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">InThread</span>(T);</span><br><span class="line">		<span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">			pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!= <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">InThread</span>(T-&gt;lchild);</span><br><span class="line">		<span class="built_in">visit</span>(T);</span><br><span class="line">		<span class="built_in">InThread</span>(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		q-&gt;lchild = pre;</span><br><span class="line">		q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pre-&gt;rchild = q;</span><br><span class="line">		pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pre = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先序线索化会出现循环遍历的问题,可以改为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">visit</span>(T);</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">PreThread</span>(T-&gt;lchild);</span><br><span class="line">		<span class="built_in">PreThread</span>(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="找前驱和后继"><a href="#找前驱和后继" class="headerlink" title="找前驱和后继"></a>找前驱和后继</h4><p>以下是找中序后继</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>)p = p-&gt;lchild;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">Firstnode</span>(p-&gt;rchild);</span><br><span class="line">	<span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可以实现中序遍历的另一种方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (ThreadNode* p = <span class="built_in">Firstnode</span>(T); p != <span class="literal">NULL</span>; p = <span class="built_in">Nextnode</span>(p))</span><br><span class="line">		<span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是找中序前驱</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">Lastnode</span><span class="params">(ThreadNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;rtag == <span class="number">0</span>)p = p-&gt;rchild;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Prenode</span><span class="params">(ThreadNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">Lastnode</span>(p-&gt;lchild);</span><br><span class="line">	<span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理也有了逆向中序遍历二叉树的方法</p>
<p>先序找前驱和后序找后继需要二叉树为三叉链表存储,也就是需要父节点地址</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20145216.png" alt="屏幕截图 2023-08-07 145216">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 145216.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20150745.png" alt="屏幕截图 2023-08-07 150745">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 150745.png)</p>
<h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法-顺序存储"><a href="#双亲表示法-顺序存储" class="headerlink" title="双亲表示法(顺序存储)"></a>双亲表示法(顺序存储)</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20151123.png" alt="屏幕截图 2023-08-07 151123">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 151123.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">	PTNode nodes[MaxSize];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>

<h3 id="孩子表示法-顺序-链式存储"><a href="#孩子表示法-顺序-链式存储" class="headerlink" title="孩子表示法(顺序+链式存储)"></a>孩子表示法(顺序+链式存储)</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20151604.png" alt="屏幕截图 2023-08-07 151604">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 151604.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CTNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> child;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">CTNode</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">CTNode</span>* FirstChild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	CTBox nodes[MaxSize];</span><br><span class="line">	<span class="type">int</span> n, r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>

<h3 id="孩子兄弟表示法-链式存储-树转化为二叉树"><a href="#孩子兄弟表示法-链式存储-树转化为二叉树" class="headerlink" title="孩子兄弟表示法(链式存储)&#x2F;树转化为二叉树"></a>孩子兄弟表示法(链式存储)&#x2F;树转化为二叉树</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20152023.png" alt="屏幕截图 2023-08-07 152023">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 152023.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">CSNode</span>* firstchild, * nextsibling;</span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>

<h2 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h2><p>将各个树的根视作一个树的同一层,这样就可以用类似树转化为二叉树的方法转化为二叉树</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20152154.png" alt="屏幕截图 2023-08-07 152154">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 152154.png)</p>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>树是递归定义的数据结构,所以可以用递归算法实现遍历</p>
<h3 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode *R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (R!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">visit</span>(R);</span><br><span class="line">		<span class="keyword">while</span> (R还有下一个子树)</span><br><span class="line">			<span class="built_in">PreOrder</span>(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历顺序和与之对应的二叉树的先序遍历相同</p>
<h3 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode *R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (R!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (R还有下一个子树)</span><br><span class="line">			<span class="built_in">PreOrder</span>(T);</span><br><span class="line">        <span class="built_in">visit</span>(R);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历顺序和与之对应的二叉树的中序遍历相同</p>
<h3 id="层次遍历-树的广度优先遍历"><a href="#层次遍历-树的广度优先遍历" class="headerlink" title="层次遍历(树的广度优先遍历)"></a>层次遍历(树的广度优先遍历)</h3><p>和二叉树的层次遍历类似</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20153024.png" alt="屏幕截图 2023-08-07 153024">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 153024.png)</p>
<h2 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h2><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20153350.png" alt="屏幕截图 2023-08-07 153350">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 153350.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20153446.png" alt="屏幕截图 2023-08-07 153446">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 153446.png)</p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20153810.png" alt="屏幕截图 2023-08-07 153810">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 153810.png)</p>
<p>哈夫曼树,也称最优二叉树,是在含有n个带权结点的二叉树中,WPL最小的二叉树</p>
<h3 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20154437.png" alt="屏幕截图 2023-08-07 154437">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 154437.png)</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>固定长度编码:每个字符用相等长度的二进制数字表示,ASC2就是固定长度编码</p>
<p>当有了编码的定义,可以用树来分辨得到的编码</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20155036.png" alt="屏幕截图 2023-08-07 155036">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 155036.png)</p>
<p>但每个英文字母的使用频率不一样,所以可以用较少的编码表示使用较多的字母,用较多的编码表示使用较少的字母</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20155447.png" alt="屏幕截图 2023-08-07 155447">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-07 155447.png)</p>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集是一种集合数据结构,只实现”并”和”查”两种操作</p>
<p>如果我们想查一个元素所属集合,或者合并两个集合,该如何做?</p>
<p>我们可以用树来表示这种数据结构,问题就会简单很多</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20151518.png" alt="屏幕截图 2023-08-08 151518">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 151518.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int UFSets[MaxSize];</span><br><span class="line"></span><br><span class="line">void Initial(int s[])</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 0; i &lt; MaxSize; i++)</span><br><span class="line">		s[i] = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20153001.png" alt="屏幕截图 2023-08-08 153001">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 153001.png)</p>
<p>每个结点存储父节点的下标,这样查某个元素的集合,就可以变成查这个元素的根结点,合并集合,直接更改结点的父节点即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (S[x] &gt;= <span class="number">0</span>)</span><br><span class="line">		x = S[x];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Root1 == Root2)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	S[Root2] = Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Union操作优化"><a href="#Union操作优化" class="headerlink" title="Union操作优化"></a>Union操作优化</h2><p>当树很高的时候,显然Find操作的耗时将会增加,所以在合并树的时候,我们要避免增加树的高度,也就是让小树合并到大树上</p>
<p>根据上图,根结点由于没有父结点,所以父节点的值为-1,我们可以利用这个空位,改成用绝对值存储树的结点数量,这样就可以方便的得知树的大小(教程中说的是存储结点的数量,但也许存储树的深度会好些?不过问题在于如何得知树的深度)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20154941.png" alt="屏幕截图 2023-08-08 154941">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 154941.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Root1 == Root2)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(S[Root2]&gt;S[Root1])</span><br><span class="line">	&#123;</span><br><span class="line">		S[Root1] += S[Root2];</span><br><span class="line">		S[Root2] = Root1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		S[Root2] += S[Root1];</span><br><span class="line">		S[Root1] = Root2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Find操作优化-压缩路径"><a href="#Find操作优化-压缩路径" class="headerlink" title="Find操作优化(压缩路径)"></a>Find操作优化(压缩路径)</h2><p>当树很高的时候,查找路径会很长</p>
<p>我们不需要保持树的结构,因为我们只是用树的性质表示并查集,而并查集中的元素是相互没有关系的</p>
<p>比如下面的树,很高,所以我们可以进行一些调整</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20155516.png" alt="屏幕截图 2023-08-08 155516">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 155516.png)</p>
<p>我们可以将某些节点(准确的说是查找路径上的节点)的父节点直接设为根节点</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20155548.png" alt="屏幕截图 2023-08-08 155548">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 155548.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> root = x;</span><br><span class="line">	<span class="keyword">while</span> (S[root] &gt;= <span class="number">0</span>)</span><br><span class="line">		root = S[root];</span><br><span class="line">	<span class="keyword">while</span> (x!=root)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = S[x];</span><br><span class="line">		S[x] = root;</span><br><span class="line">		x = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20162648.png" alt="屏幕截图 2023-08-08 162648">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 162648.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20163244.png" alt="屏幕截图 2023-08-08 163244">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 163244.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20163407.png" alt="屏幕截图 2023-08-08 163407">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 163407.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20163558.png" alt="屏幕截图 2023-08-08 163558">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 163558.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20164022.png" alt="屏幕截图 2023-08-08 164022">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 164022.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20164251.png" alt="屏幕截图 2023-08-08 164251">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 164251.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20164443.png" alt="屏幕截图 2023-08-08 164443">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 164443.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20164524.png" alt="屏幕截图 2023-08-08 164524">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 164524.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20164631.png" alt="屏幕截图 2023-08-08 164631">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 164631.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20164809.png" alt="屏幕截图 2023-08-08 164809">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 164809.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20164834.png" alt="屏幕截图 2023-08-08 164834">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 164834.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20165044.png" alt="屏幕截图 2023-08-08 165044">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 165044.png)</p>
<h2 id="几种特殊形态的图"><a href="#几种特殊形态的图" class="headerlink" title="几种特殊形态的图"></a>几种特殊形态的图</h2><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20165205.png" alt="屏幕截图 2023-08-08 165205">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 165205.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20165247.png" alt="屏幕截图 2023-08-08 165247">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 165247.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-08%20165430.png" alt="屏幕截图 2023-08-08 165430">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-08 165430.png)</p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20140747.png" alt="屏幕截图 2023-08-09 140747">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-09 140747.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20141320.png" alt="屏幕截图 2023-08-09 141320">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-09 141320.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> Vex[MaxSize];</span><br><span class="line">	<span class="type">int</span> Edge[MaxSize][MaxSize];</span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>

<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20142211.png" alt="屏幕截图 2023-08-09 142211">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-09 142211.png)</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20142710.png" alt="屏幕截图 2023-08-09 142710">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-09 142710.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20142739.png" alt="屏幕截图 2023-08-09 142739">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-09 142739.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边/弧</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> adjvex;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ArcNode</span>* next;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">	VertexType data;</span><br><span class="line">	ArcNode* first;</span><br><span class="line">&#125;VNode,AdjList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	AdjList vertices;</span><br><span class="line">	<span class="type">int</span> vexnum, arcnum;</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure>

<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20143220.png" alt="屏幕截图 2023-08-09 143220">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-09 143220.png)</p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20143623.png" alt="屏幕截图 2023-08-09 143623">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-09 143623.png)</p>
<h2 id="广度优先遍历BFS"><a href="#广度优先遍历BFS" class="headerlink" title="广度优先遍历BFS"></a>广度优先遍历BFS</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">visit</span>(v);</span><br><span class="line">	visited[v] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">EnQueue</span>(Q, v);</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DeQueue</span>(Q, v);</span><br><span class="line">		<span class="keyword">for</span> (Vex w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))</span><br><span class="line">			<span class="keyword">if</span> (!visited[w])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">visit</span>(w);</span><br><span class="line">				visited[w] = <span class="literal">true</span>;</span><br><span class="line">				<span class="built_in">EnQueue</span>(Q, w);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFS遍历序列不唯一</p>
<p>如果一个图不是连通图,或者起点与某些结点间没有路径,BFS无法全部遍历,用以下函数解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		visited[i] = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">InitQueue</span>(Q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">		<span class="keyword">if</span> (!visited[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">BFS</span>(G, i);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h3><p>我们用这种方法访问一个图时,会通过n-1条边</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-11%20092402.png" alt="屏幕截图 2023-08-11 092402">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-11 092402.png)</p>
<p>去掉没有通过的边,我们就得到了一个生成树</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-11%20092643.png" alt="屏幕截图 2023-08-11 092643">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-11 092643.png)</p>
<p>BFS遍历序列不唯一,所以广度优先生成树不唯一</p>
<p>广度优先生成森林同理</p>
<h2 id="深度优先遍历DFS"><a href="#深度优先遍历DFS" class="headerlink" title="深度优先遍历DFS"></a>深度优先遍历DFS</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTravverse</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>, v &lt; G.vexnum; ++v)</span><br><span class="line">		visited[v] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">		<span class="keyword">if</span> (!visited[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">DFS</span>(G, v);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">visit</span>(v);</span><br><span class="line">	vivited[v] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;<span class="built_in">NextNeighbor</span>(G,v,w))</span><br><span class="line">		<span class="keyword">if</span>(!visited[w])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">DFS</span>(G, w);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样,DFS遍历序列不同,深度优先生成树不同</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>一个图生成的树的集合中,权值总和最小的树称为这个图的最小生成树</p>
<p>同一个图的最小生成树可能不唯一</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-14%20182615.png" alt="屏幕截图 2023-08-14 182615">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-14 182615.png)</p>
<p>适用于边稠密图</p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-14%20182815.png" alt="屏幕截图 2023-08-14 182815">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-14 182815.png)</p>
<p>适用于边稀疏图</p>
<h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-14%20183823.png" alt="屏幕截图 2023-08-14 183823">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-14 183823.png)</p>
<p>BFS有一定的局限性,不能适用于带权图</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20093539.png" alt="屏幕截图 2023-08-17 093539">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 093539.png)</p>
<p>第一轮:遍历所有的数组信息,找到还没确定最短路径,且dist最小的顶点Vi,另final[i] &#x3D; true</p>
<p>检查所有邻接自Vi的顶点,若其final的值为false,则更新dist和path信息</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20094006.png" alt="屏幕截图 2023-08-17 094006">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 094006.png)</p>
<p>第二轮同理,循环往复直至final中所有的值都为true</p>
<p>如果带权图中有负权值的边,则Dijkstra算法可能会失效</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20095302.png" alt="屏幕截图 2023-08-17 095302">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 095302.png)</p>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>佛洛依德算法用到了动态规划思想</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20100143.png" alt="屏幕截图 2023-08-17 100143">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 100143.png)</p>
<p>#初始:两顶点间不允许有中转点,记录两顶点间的路径长度</p>
<p>#0:若允许在V0中转,求A^0和path^0</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20102504.png" alt="屏幕截图 2023-08-17 102504">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 102504.png)</p>
<p>#1:若允许在V1中转,求A^1和path^1</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20102733.png" alt="屏幕截图 2023-08-17 102733">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 102733.png)</p>
<p>#2:若允许在V2中转,求A^2和path^2</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20102917.png" alt="屏幕截图 2023-08-17 102917">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 102917.png)</p>
<p>最后用递归的方式找到完整路径</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20104122.png" alt="屏幕截图 2023-08-17 104122">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 104122.png)</p>
<p>Floyd算法不能解决有负权回路的图</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20104233.png" alt="屏幕截图 2023-08-17 104233">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 104233.png)</p>
<h2 id="有向无环图循环表达式"><a href="#有向无环图循环表达式" class="headerlink" title="有向无环图循环表达式"></a>有向无环图循环表达式</h2><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20104534.png" alt="屏幕截图 2023-08-17 104534">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 104534.png)</p>
<p>算术表达式可以用树来表示</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20104606.png" alt="屏幕截图 2023-08-17 104606">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 104606.png)</p>
<p>上图中的表达式有一些重复的部分,((c+d)*e),所以可以删除一个子树</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20104712.png" alt="屏幕截图 2023-08-17 104712">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-17 104712.png)</p>
<p>于是这个树就变成了一个图,继续合并,成为以下有向无环图</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20121059.png" alt="屏幕截图 2023-08-18 121059">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-18 121059.png)</p>
<p>最终的有向无环图中不会出现重复的操作数</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20121242.png" alt="屏幕截图 2023-08-18 121242">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-18 121242.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20121328.png" alt="屏幕截图 2023-08-18 121328">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-18 121328.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20121609.png" alt="屏幕截图 2023-08-18 121609">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-18 121609.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20124343.png" alt="屏幕截图 2023-08-18 124343">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-18 124343.png)</p>
<p>最终得到的有向无环图可能不唯一</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20125143.png" alt="屏幕截图 2023-08-18 125143">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-18 125143.png)</p>
<h3 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20125436.png" alt="屏幕截图 2023-08-18 125436">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-18 125436.png)</p>
<p>简单的说,拓扑排序就是找到做事的先后顺序</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20103021.png" alt="屏幕截图 2023-08-20 103021">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 103021.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20103340.png" alt="屏幕截图 2023-08-20 103340">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 103340.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20103402.png" alt="屏幕截图 2023-08-20 103402">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 103402.png)</p>
<h3 id="逆拓扑排序"><a href="#逆拓扑排序" class="headerlink" title="逆拓扑排序"></a>逆拓扑排序</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20104149.png" alt="屏幕截图 2023-08-20 104149">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 104149.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20104819.png" alt="屏幕截图 2023-08-20 104819">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 104819.png)</p>
<p>拓扑排序和逆拓扑排序的序列可能不唯一</p>
<p>拓扑排序和逆拓扑排序的图不能有环</p>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><h3 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20105537.png" alt="屏幕截图 2023-08-20 105537">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 105537.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20105640.png" alt="屏幕截图 2023-08-20 105640">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 105640.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20110108.png" alt="屏幕截图 2023-08-20 110108">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 110108.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20110349.png" alt="屏幕截图 2023-08-20 110349">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 110349.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20110636.png" alt="屏幕截图 2023-08-20 110636">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 110636.png)</p>
<h3 id="求关键路径"><a href="#求关键路径" class="headerlink" title="求关键路径"></a>求关键路径</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20110726.png" alt="屏幕截图 2023-08-20 110726">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 110726.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20111147.png" alt="屏幕截图 2023-08-20 111147">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 111147.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20111800.png" alt="屏幕截图 2023-08-20 111800">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 111800.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20111814.png" alt="屏幕截图 2023-08-20 111814">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 111814.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20111814.png" alt="屏幕截图 2023-08-20 111814">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 111814.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20111814.png" alt="屏幕截图 2023-08-20 111814">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 111814.png)</p>
<p>若关键活动耗时增加,再整个工程的工期将增长</p>
<p>缩短关键活动的时间,就能缩短整个工程的工期</p>
<p>当缩短到一定程度时,关键活动可能变成非关键活动</p>
<p>可能有多条关键路径,只提高一条关键路径上的关键活动的速度并不能缩短整个工程的工期,只有加快那些包括在所有关键路径上的活动才能缩短工期的目的</p>
<h1 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h1><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20112538.png" alt="屏幕截图 2023-08-20 112538">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 112538.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20112859.png" alt="屏幕截图 2023-08-20 112859">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 112859.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-20%20112951.png" alt="屏幕截图 2023-08-20 112951">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-20 112951.png)</p>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>也叫线性查找,通常用于线性表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType* elem;</span><br><span class="line">	<span class="type">int</span> TableLen;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,ElemType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ST.TableLen &amp;&amp; ST.elem[i] != key; i++);</span><br><span class="line">	<span class="keyword">return</span> i == ST.TableLen ? <span class="number">-1</span> : i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="“哨兵”方法"><a href="#“哨兵”方法" class="headerlink" title="“哨兵”方法"></a>“哨兵”方法</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-24%20141755.png" alt="屏幕截图 2023-08-24 141755">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-24 141755.png)</p>
<h3 id="顺序查找的优化"><a href="#顺序查找的优化" class="headerlink" title="顺序查找的优化"></a>顺序查找的优化</h3><h4 id="对有序表"><a href="#对有序表" class="headerlink" title="对有序表"></a>对有序表</h4><p>如果一个数字列表是有序的,比如从小到大,如果我们要查找21,但已经查到29了也没有查到,说明之后也不会查找,可以直接判断查找失败</p>
<p>这中方法有效避免了查找失败情况下不必要的查找</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-24%20142236.png" alt="屏幕截图 2023-08-24 142236">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-24 142236.png)</p>
<h4 id="被查概率不相等"><a href="#被查概率不相等" class="headerlink" title="被查概率不相等"></a>被查概率不相等</h4><p>如果我们已知列表中元素被查的概率,那么我们也可以将被查概率高的元素放在列表前面</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-24%20142552.png" alt="屏幕截图 2023-08-24 142552">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-24 142552.png)</p>
<p>显然,如果你用被查概率排序元素,就无法同时使用有序表</p>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>又称”二分查找”,仅适用于有序表</p>
<p>对于查找一个有序表中的元素,我们可以先查找表中最中间的元素,或者说将中间的被查元素与查找目标做比较,如果被查元素较大,就将有序表以中间的元素为中心切半,查找较小边的最中间的元素,往复此步,被查元素较小同理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(SSTable L,ElemType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="type">int</span> low = <span class="number">0</span>, high = L.TableLen - <span class="number">1</span>, mid;</span><br><span class="line">	 <span class="keyword">while</span> (low&lt;=high)</span><br><span class="line">	 &#123;</span><br><span class="line">		 mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">		 <span class="keyword">if</span> (L.elem[mid] == key)</span><br><span class="line">			 <span class="keyword">return</span> mid;</span><br><span class="line">		 <span class="keyword">else</span> <span class="keyword">if</span> (L.elem[mid] &gt; key)</span><br><span class="line">			 high = mid - <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">else</span></span><br><span class="line">			 low = mid + <span class="number">1</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="*查找效率分析"></a>*查找效率分析</h3><h3 id="查找判定树的构造"><a href="#查找判定树的构造" class="headerlink" title="*查找判定树的构造"></a>*查找判定树的构造</h3><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>将一个序列分成若干个区间,区间间是有序的,区间内是无序的</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-25%20101420.png" alt="屏幕截图 2023-08-25 101420">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-25 101420.png)</p>
<p>查找时,先比对查找目标在哪个块中,在相应块中顺序查找</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-25%20103241.png" alt="屏幕截图 2023-08-25 103241">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-25 103241.png)</p>
<h2 id="二叉排序树BST"><a href="#二叉排序树BST" class="headerlink" title="二叉排序树BST"></a>二叉排序树BST</h2><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-25%20105308.png" alt="屏幕截图 2023-08-25 105308">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-25 105308.png)</p>
<h3 id="BST的查找"><a href="#BST的查找" class="headerlink" title="BST的查找"></a>BST的查找</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-25%20105422.png" alt="屏幕截图 2023-08-25 105422">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-25 105422.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> key;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">BSTNode</span>* lchild, * rchild;</span><br><span class="line">&#125;BSTNode, * BSTree;</span><br><span class="line"></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (T != <span class="literal">NULL</span> &amp;&amp; key != T-&gt;key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (key &lt; T-&gt;key)T = T-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span> T = T-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于BST的递归特性,我们也可以递归实现算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BSTSearch</span><span class="params">(BSTree T,<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (key == T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">BSTSearch</span>(T-&gt;lchild, key);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">BSTSearch</span>(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BST的插入"><a href="#BST的插入" class="headerlink" title="BST的插入"></a>BST的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T = (BSTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">		T-&gt;key = k;</span><br><span class="line">		T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (k == T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (k &lt; T-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;lchild, k);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;rchild, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BST构造"><a href="#BST构造" class="headerlink" title="BST构造"></a>BST构造</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creat_BST</span><span class="params">(BSTree &amp;T,<span class="type">int</span> str[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">BST_Insert</span>(T, str[i]);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BST的删除"><a href="#BST的删除" class="headerlink" title="BST的删除"></a>BST的删除</h3><p>首先要查找这个结点,如果目标结点是叶子节点,那么可以直接删除,如果是其他情况</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-25%20111236.png" alt="屏幕截图 2023-08-25 111236">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-25 111236.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-25%20111528.png" alt="屏幕截图 2023-08-25 111528">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-25 111528.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-25%20111809.png" alt="屏幕截图 2023-08-25 111809">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-25 111809.png)</p>
<p>当我们对BST进行查找的时候,显然ASL的大小取决与BST的深度,为了减少ASL,我们要减少BST的深度</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-25%20144434.png" alt="屏幕截图 2023-08-25 144434">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-25 144434.png)</p>
<h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><p>在插入结点后，从插入点往回找到第一个不平衡结点，调整该节点为根的子树，每次调整的对象都是最小不平衡子树</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-25%20144641.png" alt="屏幕截图 2023-08-25 144641">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-25 144641.png)</p>
<h3 id="调整最小不平衡树"><a href="#调整最小不平衡树" class="headerlink" title="调整最小不平衡树"></a>调整最小不平衡树</h3><p>调整最小不平衡树分为4种情况</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-25%20145321.png" alt="屏幕截图 2023-08-25 145321">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-25 145321.png)</p>
<h4 id="调整LL和RR"><a href="#调整LL和RR" class="headerlink" title="调整LL和RR"></a>调整LL和RR</h4><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20102208.png" alt="屏幕截图 2023-08-27 102208">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-27 102208.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20105558.png" alt="屏幕截图 2023-08-27 105558">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-27 105558.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20105708.png" alt="屏幕截图 2023-08-27 105708">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-27 105708.png)</p>
<h4 id="调整LR和RL"><a href="#调整LR和RL" class="headerlink" title="调整LR和RL"></a>调整LR和RL</h4><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20105937.png" alt="屏幕截图 2023-08-27 105937">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-27 105937.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20110152.png" alt="屏幕截图 2023-08-27 110152">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-27 110152.png)</p>
<h3 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-27%20112450.png" alt="屏幕截图 2023-08-27 112450">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-27 112450.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-28%20140427.png" alt="屏幕截图 2023-08-28 140427">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-28 140427.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-28%20140541.png" alt="屏幕截图 2023-08-28 140541">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-28 140541.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-28%20140547.png" alt="屏幕截图 2023-08-28 140547">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-28 140547.png)</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20142613.png" alt="屏幕截图 2023-08-30 142613">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-30 142613.png)</p>
<p>在平衡二叉树的中,每插入&#x2F;删除一个结点,很可能很破坏AVL的特性,需要平凡调整树的形态</p>
<p>在红黑树中,插入&#x2F;删除很多时候不会破坏红黑特性,即使需要调整,一般都可以在常数级时间内完成</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>红黑树是一种二叉排序树,并且</p>
<ol>
<li>每个结点要么是红的,要么是黑的</li>
<li>根结点是黑色的;叶结点(外部结点,NULL结点,失败结点)是黑色的</li>
<li>不存在两个相邻的红结点(也就是说红结点的父结点和孩子结点均是黑色)</li>
<li>对每个结点,从该结点到任意叶结点的简单路径上,所含黑结点的数目相同</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RBNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	RBNode* parent;</span><br><span class="line">	RBNode* lChild;</span><br><span class="line">	RBNode* rChild;</span><br><span class="line">	<span class="type">int</span> color;<span class="comment">// 0/1-black/red </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结点的黑高bh:从某结点出发(不含该结点)到达任意空叶结点的路径上黑结点总数</p>
<p>如果根结点的黑高为h，内部结点数至少为2^h-1个</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>从根结点到叶结点的最长路径不大于最短路径的2倍</li>
<li>有n个内部结点的红河树高度h&lt;&#x3D;2log2(n+1)</li>
</ol>
<h3 id="查找-3"><a href="#查找-3" class="headerlink" title="查找"></a>查找</h3><p>与BST、AVL相同，从根出发，左小右大，若查找到一个空叶结点，则查找失败</p>
<h3 id="插入-3"><a href="#插入-3" class="headerlink" title="插入"></a>插入</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-31%20103741.png" alt="屏幕截图 2023-08-31 103741">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-31 103741.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-31%20104529.png" alt="屏幕截图 2023-08-31 104529">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-31 104529.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-31%20104625.png" alt="屏幕截图 2023-08-31 104625">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-31 104625.png)</p>
<p>插入的每个新结点,如果破坏红黑树的特性,一定是破坏不红红（定义中的第三条）的特性</p>
<h3 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h3><p>考研不考，所以没教</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>我们讨论过许多二叉的排序树，现在我们尝试将排序树的定义发散到m叉树</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-31%20121758.png" alt="屏幕截图 2023-08-31 121758">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-31 121758.png)</p>
<p>如果每个结点的关键字大少，导致树变高，要查找很多层，效率低</p>
<p>可以规定m叉查找树中，除了根结点外，任何结点至少有[m&#x2F;2]个分叉,即至少有[m&#x2F;2]-1个关键字</p>
<p>树不平衡，也会使查找树过高</p>
<p>规定m叉查找树中，对于任何一个结点，其所有子树的高度都要相同</p>
<p>满足以上两个条件的m叉查找树，称为B树</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-31%20122917.png" alt="屏幕截图 2023-08-31 122917">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-31 122917.png)</p>
<p>B树，或称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示，一棵m阶B树或为空树，或满足以下特性</p>
<ol>
<li>树中每个结点至多有m棵子树，即至多有m-1个关键字</li>
<li>若根结点不是终端结点，则至少有两课子树</li>
<li>除了根结点外，任何非叶结点至少有[m&#x2F;2]棵子树,即至少有[m&#x2F;2]-1个关键字</li>
<li>所有叶结点出现在同一层次上，并且不带信息</li>
<li>所有非叶结点的结构如下</li>
</ol>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-31%20123257.png" alt="屏幕截图 2023-08-31 123257">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-31 123257.png)</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-31%20222616.png" alt="屏幕截图 2023-08-31 222616">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-31 222616.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-31%20222015.png" alt="屏幕截图 2023-08-31 222015">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-08-31 222015.png)</p>
<h3 id="插入-4"><a href="#插入-4" class="headerlink" title="插入"></a>插入</h3><p>我们现在讨论5阶B树</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-01%20122530.png" alt="屏幕截图 2023-09-01 122530">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-09-01 122530.png)</p>
<p>新元素一定是插入到最底层”终端结点”,用”查找”确定插入位置</p>
<h3 id="删除-4"><a href="#删除-4" class="headerlink" title="删除"></a>删除</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1b7411N798/?p=80&spm_id_from=pageDriver&vd_source=4ec457bb4f6cbb496da2800adbe93b46">7.4_2_B树的插入删除_哔哩哔哩_bilibili</a></p>
<p>如果删除的关键字在终端节点,则直接删除关键字要注意关键字个数是否低于下限[m&#x2F;2]-1</p>
<p>如果要删除的关键字不是终端节点,则用直接前驱或直接后继来代替被删除的关键字</p>
<p>相当于删除了直接前驱或直接后继,最终会删除到终端结点</p>
<p>直接前驱:当前关键字左侧指针所指子树中”最右下”的元素</p>
<p>直接后继:当前关键字右侧指针所指子树中”最左下”的元素</p>
<p>所以所有的删除非终端结点的情况都可以转换为删除中断结点的情况</p>
<p>如果删除终端结点后关键字个数低于下限:</p>
<p>![屏幕截图 2023-09-02 163153](F:\教材和作业\一些笔记\屏幕截图 2023-09-02 163153.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20163621.png" alt="屏幕截图 2023-09-02 163621">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-09-02 163621.png)</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20163956.png" alt="屏幕截图 2023-09-02 163956">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-09-02 163956.png)</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20164228.png" alt="屏幕截图 2023-09-02 164228">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-09-02 164228.png)</p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>一棵m阶B+树需要满足如下条件:</p>
<ol>
<li>每个分支结点最多有m棵子树</li>
<li>如果一个结点不是叶结点,则该节点至少有两棵子树,其他每个分支结点至少有[m&#x2F;2]棵子树</li>
<li>结点的子树个数与关键字个数相等</li>
<li>所有的叶子结点包含全部的关键字及指向相应记录的指针,叶子结点中将关键字按大小顺序排列,并且相邻叶子结点按大小顺序相互链接起</li>
<li>所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针</li>
</ol>
<h3 id="查找-4"><a href="#查找-4" class="headerlink" title="查找"></a>查找</h3><p>可以用类似分块查找的方式,也可以用叶结点链表顺序查找</p>
<h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>散列表Hash Table,又称哈希表,是一种数据结构,其数据元素的关键字与其存储地址直接相关</p>
<p>通过散列函数(哈希函数)建立关键字与存储地址的联系</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20173205.png" alt="屏幕截图 2023-09-02 173205">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-09-02 173205.png)</p>
<p>如果不同的关键字通过散列函数映射到同一个值,则称它们是”同义词”</p>
<p>通过散列函数确定的位置已经存放了其他元素,则称这种情况为”冲突”</p>
<p>用拉链法(链接法,链地址法)处理冲突:把所有同义词放在一个链表中</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20173418.png" alt="屏幕截图 2023-09-02 173418">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-09-02 173418.png)</p>
<p>通过计算ASL可以发现,用拉链法处理,如果链越长,则ASL越大,所以我们需要一个更合理的哈希函数来减少同义词</p>
<p>散列查找是用空间换时间的算法,理论上来说,散列表越长,冲突的可能性越低,时间复杂度越小</p>
<p>装填因子:表中记录数&#x2F;散列表长度</p>
<h3 id="常见的散列函数"><a href="#常见的散列函数" class="headerlink" title="常见的散列函数"></a>常见的散列函数</h3><h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>H(key) &#x3D; key&amp;p</p>
<p>散列表长度为m,取一个不大于m但最接近或等于m的质数p</p>
<p>取质数是为了减少冲突</p>
<h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><p>H(key) &#x3D; key 或 H(key) &#x3D; a*key + b</p>
<p>a和b是常数,这种方法计算简单,不会产生冲突,适合关键字分布基本连续的情况,若关键字分布不连续,空位较多,会造成存储空间的浪费</p>
<h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>选取数码分布较为均匀的若干位作为散列地址</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-02%20175507.png" alt="屏幕截图 2023-09-02 175507">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-09-02 175507.png)</p>
<h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p>取关键字的平方值的中间值作为散列地址</p>
<p>中间值具体取多少位视情况而定,这种方法得到的散列地址与关键字的每位都有关系,因此散列地址分布比较均匀</p>
<h3 id="冲突处理-开放定址法"><a href="#冲突处理-开放定址法" class="headerlink" title="冲突处理-开放定址法"></a>冲突处理-开放定址法</h3><p>我们也可以选用其他的冲突处理方法尝试减少时间复杂度</p>
<p>开放定址法,是指可存放新表项的空闲地址既向它的同义词开放,又向它的非同一次表项开放</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20120433.png" alt="屏幕截图 2023-09-03 120433">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-09-03 120433.png)</p>
<h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p>di &#x3D; 0,1,2,3,4,…,m-1</p>
<p>用线性探测法查找时,如果向后查找到空结点,就可以判断查找失败</p>
<p>在删除时,如果我们直接删除查找到的元素,以后可能出现表中有目标元素但查找到空结点的情况</p>
<p>可以在删除元素的结点上作bool标记,表明该结点删除过元素</p>
<p>这中方法的查找效率极低</p>
<h4 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h4><p>di &#x3D; 0^2,1^2,-1^2,2^2,-2^2….k^2,-k^2</p>
<p>如果用平方探测法,哈希表长度m必须是一个可以表示成4j+3的素数,才能探测到所有位置</p>
<h4 id="再散列法"><a href="#再散列法" class="headerlink" title="再散列法"></a>再散列法</h4><p>除了原始的散列函数之外,多准备几个散列函数,当散列函数冲突时,用下一个散列函数计算一个新地址,直到不冲突为止</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序是将表中的元素按关键字重新排列,使元素有序的过程</p>
<p>算法的稳定性:排序时可能会出现元素关键字相同的情况,如果一个算法排序总是使两个关键字相同的元素的顺序不变,就称这个算法是稳定的,否则是不稳定的</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>当一个待排序的记录按其关键字大小插入到前面已排号序的子序列中,直到全部记录插入完成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			temp = A[i];</span><br><span class="line">			<span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; temp; --j)</span><br><span class="line">				A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">			A[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间复杂度O(n),最坏时间复杂度O(n^2)</p>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>我们可以先用折半查找找到应该插入的位置,再移动元素,以此来优化算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, temp;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; a[i - <span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">		temp = a[i];</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> low = <span class="number">0</span>, high = i - <span class="number">1</span>, mid;</span><br><span class="line">		<span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">		&#123;</span><br><span class="line">			mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (a[mid] &gt; temp)</span><br><span class="line">				high = mid - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				low = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(j = i;j&gt;low;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		a[low] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>如果我们要排序一个表,那么最好的情况就是这个表本来就是有序的,或者比较好的情况是这个表是基本有序的</p>
<p>希尔排序:将待排序表分割成若干形如L[i,i+d,i+2d,…,i+kd]的,也就是表中相距距离为d的元素组成的特殊子表,对各个子表分别进行插入排序,缩小增量d,重复上述过程,直到d&#x3D;1为止</p>
<p>[<img src="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-07%20135554.png" alt="屏幕截图 2023-09-07 135554">](<a target="_blank" rel="noopener" href="https://tuchuange.oss-cn-beijing.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://tuchuange.oss-cn-beijing.aliyuncs.com/img/屏幕截图</a> 2023-09-07 135554.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> d, i, j;</span><br><span class="line">	<span class="keyword">for</span> (d = n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d/=<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">for</span> (i=d+<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i]&lt;A[i-d])</span><br><span class="line">			&#123;</span><br><span class="line">				A[<span class="number">0</span>] = A[i];</span><br><span class="line">				<span class="keyword">for</span> (j = i - d; j &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[j]; j -= d)</span><br><span class="line">					A[j + d] = A[j];</span><br><span class="line">				A[j + d] = A[<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希尔排序是不稳定的</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a ,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;n<span class="number">-1</span> ;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = n<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">swap</span>(A[j - <span class="number">1</span>], A[j]);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!flag)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序是稳定的</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>在待排序的表L中任意一个元素作为枢轴(通常取首元素),通过一趟排序将待排序表划分为独立的两部分,L1,L2,使L1中的所有元素都小于枢轴,L2的所有元素都大于枢轴,这个过程叫划分,重复在分出子表划分,直至排序完成</p>
<p>每次划分,都能将枢轴摆放到最终位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> pivot = A[low];</span><br><span class="line">	<span class="keyword">while</span>(low&lt;high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot)</span><br><span class="line">			high--;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot)</span><br><span class="line">			low++;</span><br><span class="line">		A[high] = A[low];</span><br><span class="line">	&#125;</span><br><span class="line">	A[low] = pivot;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;high)</span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="type">int</span> pivotpos = <span class="built_in">Partition</span>(A, low, high);</span><br><span class="line">		<span class="built_in">QuickSort</span>(A, low, pivotpos - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">QuickSort</span>(A, pivotpos + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>*归并排序通常使用二路归并</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* B = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (k = low;k&lt;high;k++)</span><br><span class="line">		B[k] = A[k];</span><br><span class="line">	<span class="keyword">for</span> (i = low,j = mid +<span class="number">1</span>,k = low;i&lt;=mid&amp;&amp;j&lt;=high;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (B[i] &lt;= B[j])</span><br><span class="line">			A[k] = B[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			A[k] = B[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)A[k++] = B[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= high)A[k++] = B[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &gt;= high)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">MergeSort</span>(A, low, mid);</span><br><span class="line">	<span class="built_in">MergeSort</span>(A, mid+<span class="number">1</span>, high);	</span><br><span class="line">	<span class="built_in">Merge</span>(A, low, mid, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>遍历序列n-1次,每次将最小的元素放入子序列</p>
<p>时间复杂度O(n^2)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">kaka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2023/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">KAKA的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/cover/datastruct.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/08/13/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C++学习笔记"><img class="cover" src="/cover/c.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kaka</div><div class="author-info__description">还在新手期的游戏开发爱好者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">卡卡立志成为技术宅地下偶像，欢迎来到我的个人博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">静态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">1.1.2.</span> <span class="toc-text">动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.1.4.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.5.</span> <span class="toc-text">查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%8F%92%E5%85%A5"><span class="toc-number">1.2.3.</span> <span class="toc-text">按位插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E6%8F%92%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.4.</span> <span class="toc-text">后插操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E6%8F%92%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.5.</span> <span class="toc-text">前插操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-1"><span class="toc-number">1.2.6.</span> <span class="toc-text">删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">按位删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">指定节点删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE-1"><span class="toc-number">1.2.7.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">按位查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">按值查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-2"><span class="toc-number">1.3.3.</span> <span class="toc-text">删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">整表删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E9%A1%B9%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">前项遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E9%A1%B9%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">后项遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">循环单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">循环双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-1"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-2"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">插入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">静态链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.6.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.1.</span> <span class="toc-text">顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-2"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E6%A0%88"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">入栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E6%A0%88"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">出栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.2.</span> <span class="toc-text">获取栈顶元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">1.6.3.</span> <span class="toc-text">*共享栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.4.</span> <span class="toc-text">链式存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E8%BE%93%E5%87%BA%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7"><span class="toc-number">1.6.5.</span> <span class="toc-text">判断输出序列的合法性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.7.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.7.1.</span> <span class="toc-text">顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%98%9F"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E9%98%9F"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">出队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%A4%B4"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">查看队头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%88%A4%E6%96%AD%E9%98%9F%E6%BB%A1%E7%9A%84%E5%8A%9E%E6%B3%95"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">*其他判断队满的办法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-number">1.7.2.</span> <span class="toc-text">链式存储结构(带头结点)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-3"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%98%9F-1"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E9%98%9F-1"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">出队</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.7.3.</span> <span class="toc-text">双端队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.7.4.</span> <span class="toc-text">队列的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">2.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.</span> <span class="toc-text">顺序存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%AD%90%E4%B8%B2"><span class="toc-number">2.1.1.</span> <span class="toc-text">求子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">比较两个串的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.1.3.</span> <span class="toc-text">定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.2.</span> <span class="toc-text">链式存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">朴素模式匹配算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">2.4.1.</span> <span class="toc-text">算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82next%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.3.</span> <span class="toc-text">求next数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.4.</span> <span class="toc-text">next数组的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82nextval%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.5.</span> <span class="toc-text">求nextval数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">3.1.</span> <span class="toc-text">树的定义和基本术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.2.</span> <span class="toc-text">树的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.3.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">完全二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.4.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8-1"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8-1"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">链式存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88-%E4%B8%AD-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.3.5.</span> <span class="toc-text">二叉树的先&#x2F;中&#x2F;后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.3.6.</span> <span class="toc-text">二叉树的层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.3.7.</span> <span class="toc-text">由遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.3.8.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">3.3.8.1.</span> <span class="toc-text">二叉树的线索化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%89%8D%E9%A9%B1%E5%92%8C%E5%90%8E%E7%BB%A7"><span class="toc-number">3.3.8.2.</span> <span class="toc-text">找前驱和后继</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">双亲表示法(顺序存储)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%A1%BA%E5%BA%8F-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">孩子表示法(顺序+链式存储)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8-%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.4.3.</span> <span class="toc-text">孩子兄弟表示法(链式存储)&#x2F;树转化为二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.5.</span> <span class="toc-text">森林和二叉树的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.</span> <span class="toc-text">树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.1.</span> <span class="toc-text">先根遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.2.</span> <span class="toc-text">后根遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.3.</span> <span class="toc-text">层次遍历(树的广度优先遍历)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.7.</span> <span class="toc-text">森林的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">3.8.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-number">3.8.1.</span> <span class="toc-text">带权路径长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">3.8.2.</span> <span class="toc-text">构造哈夫曼树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">3.8.3.</span> <span class="toc-text">哈夫曼编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Union%E6%93%8D%E4%BD%9C%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">Union操作优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Find%E6%93%8D%E4%BD%9C%E4%BC%98%E5%8C%96-%E5%8E%8B%E7%BC%A9%E8%B7%AF%E5%BE%84"><span class="toc-number">4.2.</span> <span class="toc-text">Find操作优化(压缩路径)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">5.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">5.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E5%BD%A2%E6%80%81%E7%9A%84%E5%9B%BE"><span class="toc-number">5.2.</span> <span class="toc-text">几种特殊形态的图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.</span> <span class="toc-text">图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">5.3.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">5.3.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">5.3.3.</span> <span class="toc-text">十字链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-number">5.3.4.</span> <span class="toc-text">邻接多重表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86BFS"><span class="toc-number">5.4.</span> <span class="toc-text">广度优先遍历BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">5.4.1.</span> <span class="toc-text">广度优先生成树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DFS"><span class="toc-number">5.5.</span> <span class="toc-text">深度优先遍历DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">5.6.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-number">5.6.1.</span> <span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">5.6.2.</span> <span class="toc-text">Kruskal算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.7.</span> <span class="toc-text">最短路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS"><span class="toc-number">5.7.1.</span> <span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">5.7.2.</span> <span class="toc-text">Dijkstra算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="toc-number">5.7.3.</span> <span class="toc-text">Floyd算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E5%BE%AA%E7%8E%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.8.</span> <span class="toc-text">有向无环图循环表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">5.9.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOV%E7%BD%91"><span class="toc-number">5.9.1.</span> <span class="toc-text">AOV网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-1"><span class="toc-number">5.9.2.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">5.9.3.</span> <span class="toc-text">逆拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">5.10.</span> <span class="toc-text">关键路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOE%E7%BD%91"><span class="toc-number">5.10.1.</span> <span class="toc-text">AOE网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">5.10.2.</span> <span class="toc-text">求关键路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE-2"><span class="toc-number">6.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">6.1.</span> <span class="toc-text">顺序查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E5%93%A8%E5%85%B5%E2%80%9D%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.1.</span> <span class="toc-text">“哨兵”方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">6.1.2.</span> <span class="toc-text">顺序查找的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%9C%89%E5%BA%8F%E8%A1%A8"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">对有序表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E6%9F%A5%E6%A6%82%E7%8E%87%E4%B8%8D%E7%9B%B8%E7%AD%89"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">被查概率不相等</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">6.2.</span> <span class="toc-text">折半查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">6.2.1.</span> <span class="toc-text">*查找效率分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">6.2.2.</span> <span class="toc-text">*查找判定树的构造</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">6.3.</span> <span class="toc-text">分块查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91BST"><span class="toc-number">6.4.</span> <span class="toc-text">二叉排序树BST</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">6.4.1.</span> <span class="toc-text">BST的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">6.4.2.</span> <span class="toc-text">BST的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E6%9E%84%E9%80%A0"><span class="toc-number">6.4.3.</span> <span class="toc-text">BST构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">6.4.4.</span> <span class="toc-text">BST的删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.5.</span> <span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">6.5.1.</span> <span class="toc-text">平衡二叉树的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">6.5.2.</span> <span class="toc-text">调整最小不平衡树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E6%95%B4LL%E5%92%8CRR"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">调整LL和RR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E6%95%B4LR%E5%92%8CRL"><span class="toc-number">6.5.2.2.</span> <span class="toc-text">调整LR和RL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">6.5.3.</span> <span class="toc-text">平衡二叉树的删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">6.6.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">6.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">6.6.2.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE-3"><span class="toc-number">6.6.3.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-3"><span class="toc-number">6.6.4.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-3"><span class="toc-number">6.6.5.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-number">6.7.</span> <span class="toc-text">B树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">6.7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">6.7.2.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-4"><span class="toc-number">6.7.3.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-4"><span class="toc-number">6.7.4.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">6.8.</span> <span class="toc-text">B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">6.8.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE-4"><span class="toc-number">6.8.2.</span> <span class="toc-text">查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE"><span class="toc-number">6.9.</span> <span class="toc-text">散列查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">6.9.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">6.9.2.</span> <span class="toc-text">常见的散列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95"><span class="toc-number">6.9.2.1.</span> <span class="toc-text">除留余数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">6.9.2.2.</span> <span class="toc-text">直接定址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">6.9.2.3.</span> <span class="toc-text">数字分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95"><span class="toc-number">6.9.2.4.</span> <span class="toc-text">平方取中法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86-%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">6.9.3.</span> <span class="toc-text">冲突处理-开放定址法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-number">6.9.3.1.</span> <span class="toc-text">线性探测法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-number">6.9.3.2.</span> <span class="toc-text">平方探测法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E6%95%A3%E5%88%97%E6%B3%95"><span class="toc-number">6.9.3.3.</span> <span class="toc-text">再散列法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">折半插入排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">7.4.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">7.5.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">7.6.</span> <span class="toc-text">简单选择排序</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/09/shader%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%E2%80%94%E2%80%94CurvedWorld/" title="shader学习实例——CurvedWorld"><img src="/cover/shader.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shader学习实例——CurvedWorld"/></a><div class="content"><a class="title" href="/2024/03/09/shader%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%E2%80%94%E2%80%94CurvedWorld/" title="shader学习实例——CurvedWorld">shader学习实例——CurvedWorld</a><time datetime="2024-03-09T11:31:38.000Z" title="发表于 2024-03-09 19:31:38">2024-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/13/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C++学习笔记"><img src="/cover/c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++学习笔记"/></a><div class="content"><a class="title" href="/2023/08/13/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C++学习笔记">C++学习笔记</a><time datetime="2023-08-13T15:35:54.000Z" title="发表于 2023-08-13 23:35:54">2023-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据结构与算法学习笔记"><img src="/cover/datastruct.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法学习笔记"/></a><div class="content"><a class="title" href="/2023/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据结构与算法学习笔记">数据结构与算法学习笔记</a><time datetime="2023-07-09T14:56:41.000Z" title="发表于 2023-07-09 22:56:41">2023-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By kaka</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>